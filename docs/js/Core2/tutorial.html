<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Tutorial: Discrete Event Simulation with OESjs-Core2</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="tutorial_files/ebook.css" rel="stylesheet" type="text/css" /><meta content="OES" name="og:site_name" /><meta content="Tutorial: Discrete Event Simulation with OESjs-Core2" name="og:title" /><meta content="en" name="og:locale" /><meta content="This tutorial article explains how to use the OESjs-Core2 simulation library, which implements an architecture for Object Event Simulation (OES), extending the OESjs Core 1 simulator by adding support for activities, which may be resource-constrained." name="og:description" /><meta content="https://gwagner57.github.io/oes/js/Core2/tutorial.html" name="og:url" /><meta content="https://sim4edu.com/img/sim4edu.png" name="og:image" /><meta content="summary_large_image" name="twitter:card" /><style>/*<![CDATA[*/
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
table.expStatistics tbody td {
    text-align: right;
}

div.role-book-title-div h1.role-book-title {
    margin-bottom: 0.33em;
}
div[id$="subtitle"] {
    margin-top: 0.33em;
}


div#share {
    display: block; /*inline-block*/
}
ul.links {
    list-style: none;
    padding: 0;
    margin: 0 0 0 1em;
}
ul.links li {
    display: inline;
    text-align: center;
    cursor: pointer;
    margin-right: 1em;
}
ul.links li:hover {
    text-decoration: underline;
}
.icon-social {
    width: 20px;
    height: 20px;
    background: #eee;
}/*]]>*/</style></head><body><section class="role-book" id="tutorial"><div class="role-book-title-div"><h1 class="role-book-title">Tutorial: Discrete Event Simulation <br />with OESjs-Core2</h1><div class="role-content" id="tutorial-content-1"><div id="tutorial-content-1__share"> <ul class="links"><li class="share facebook" title="Share on Facebook"><a href="https://www.facebook.com/sharer.php?u=https://gwagner57.github.io/oes/js/Core2/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-facebook" viewBox="0 0 18 18"><path d="M15.7,1.5H2.3c-0.5,0-0.8,0.4-0.8,0.8v13.3c0,0.5,0.4,0.8,0.8,0.8h7.2v-5.8h-2V8.4h2V6.8c0-1.9,1.2-3,2.9-3 c0.8,0,1.5,0.1,1.7,0.1v2l-1.2,0c-0.9,0-1.1,0.4-1.1,1.1v1.4h2.2l-0.3,2.3h-1.9v5.8h3.8c0.5,0,0.8-0.4,0.8-0.8V2.3 C16.5,1.9,16.1,1.5,15.7,1.5z"></path></symbol> <use xlink:href="#social-facebook" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share twitter" title="Share on Twitter"><a href="https://twitter.com/intent/tweet?url=https://gwagner57.github.io/oes/js/Core2/tutorial.html&amp;text=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-twitter" viewBox="0 0 18 18"><path d="M16.5,4.3c-0.6,0.2-1.1,0.4-1.8,0.5c0.6-0.4,1.1-1,1.4-1.7c-0.6,0.4-1.3,0.6-2,0.8c-0.6-0.6-1.4-1-2.2-1 c-1.7,0-3.1,1.4-3.1,3.1c0,0.2,0,0.5,0.1,0.7C6.3,6.5,4.1,5.3,2.5,3.4C2.3,3.9,2.1,4.4,2.1,5c0,1.1,0.5,2,1.4,2.6 c-0.5,0-1-0.2-1.4-0.4c0,0,0,0,0,0c0,1.5,1.1,2.8,2.5,3.1c-0.3,0.1-0.5,0.1-0.8,0.1c-0.2,0-0.4,0-0.6-0.1c0.4,1.2,1.5,2.1,2.9,2.2 c-1.1,0.8-2.4,1.3-3.8,1.3c-0.2,0-0.5,0-0.7,0c1.4,0.9,3,1.4,4.7,1.4c5.7,0,8.8-4.7,8.8-8.9c0-0.1,0-0.3,0-0.4 C15.6,5.5,16.1,4.9,16.5,4.3"></path></symbol> <use xlink:href="#social-twitter" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share linkedin" title="Share on LinkedIn"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://gwagner57.github.io/oes/js/Core2/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-linkedin" viewBox="0 0 18 18"><path d="M15.4,1.5H2.6C2,1.5,1.5,2,1.5,2.6v12.8c0,0.6,0.5,1.1,1.1,1.1h12.8c0.6,0,1.1-0.5,1.1-1.1V2.6C16.5,2,16,1.5,15.4,1.5z M3.8,7.1H6v7.2H3.8V7.1z M4.9,6.1c-0.7,0-1.3-0.6-1.3-1.3c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3C6.2,5.6,5.6,6.1,4.9,6.1z M14.5,14.3h-2.3v-3.5c0-0.8,0-1.9-1.2-1.9c-1.2,0-1.4,0.9-1.4,1.8v3.5H7.4V7.1h2.2v1h0c0.3-0.6,1-1.2,2.1-1.2 c2.3,0,2.7,1.5,2.7,3.4V14.3z"></path></symbol> <use xlink:href="#social-linkedin" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share email" title="Share with Email"><a aria-label="Share with Email" href="mailto:?subject=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs-Core2&amp;body=This%20article%20shows%20how%20to%20create%20and%20run%20a%20simulation%20model%20with%20the%20JavaScript-based%20simulation%20framework%20OESjs-Core2%20available%20on%20Sim4edu.com.%20OESjs-Core2%20implements%20the%20Object%20Event%20Simulation%20paradigm%2C%20representing%20a%20general%20Discrete%20Event%20Simulation%20approach%20based%20on%20object-oriented%20modeling%20and%20event%20scheduling.%0A%0Ahttps://gwagner57.github.io/oes/js/Core2/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-mail" viewBox="0 0 18 18"><path d="M9,8.2L3,4.5h12L9,8.2z M15,13.5H3V6l6,3.8L15,6V13.5z M15,3H3C2.2,3,1.5,3.7,1.5,4.5l0,9C1.5,14.3,2.2,15,3,15 h12c0.8,0,1.5-0.7,1.5-1.5v-9C16.5,3.7,15.8,3,15,3z"></path></symbol> <use xlink:href="#social-mail" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li></ul> </div><div id="tutorial-content-1__subtitle">How to create and run simulations with the JavaScript-based simulation library <a href="https://gwagner57.github.io/oes/">OESjs-Core2</a> available from the <a href="https://github.com/gwagner57/oes">OES GitHub repo</a></div> <div id="tutorial-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Copyright © 2020 Gerd Wagner (<a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC</a>)</p><p>Published 2020-09-16</p><h2>Abstract</h2><p>This tutorial article explains how to use the OESjs-Core2 simulation library, which implements an architecture for Object Event Simulation (OES), extending the OESjs Core 1 simulator by adding support for activities, which are composite events with some duration. Activities are composed of a start event and an end event. Resource-constrained activities are modeled by means of <em>Resource Roles</em> (with <em>Resource Constraints</em>) and <em>Resource Pools</em>. They can only be started when their required resources are available. Due to this dependency, a simulated activity cannot be scheduled like a simulated event. Rather, it has to be added to a queue of planned activities, from which it is dequeued, and scheduled via an immediate activity start event, as soon as the required resources become available. </p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index"><span class="role-label"><span class="role-number">1</span>. </span>Introduction to Object Event Modeling of Activities</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#CM"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#DesM"><span class="role-label"><span class="role-number">1.2</span>. </span>Making Simulation Design Models</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-2"><span class="role-label"><span class="role-number">2</span>. </span>Creating Activity-Based Discrete Event Simulations with OESjs-Core2</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimTime"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimModels"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimScenarios"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimStatistics"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimExperiments"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimLog"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-appendix"><a class="role-appendix-ref" href="#architecture"><span class="role-label"><span class="role-number">A</span>. </span>Simulator Architecture</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-table-ref" href="#SimModels__lot__1"><span class="role-label"><span class="role-number">2-1</span>. </span>Simulation Log</a></li><li class="role-booklist-entry"><a class="role-table-ref" href="#SimStatistics__lot__2"><span class="role-label"><span class="role-number">2-2</span>. </span>Statistics</a></li></ul></section></div><section class="role-chapter" id="index"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling of Activities</h1><p>This chapter shows how to make <em>activity-based Discrete Event Simulation models</em> using the paradigm of <em>Object Event Modeling and Simulation</em> (OEM&amp;S) with UML Class Diagrams and DPMN Process Diagrams. It is recommended to first read the tutorial <a href="https://gwagner57.github.io/oes/js/Core1/tutorial.html">Discrete Event Simulation with OESjs-Core1</a>.</p>Activities are composite events, having a start event and an end event, and a duration as the time in-between their start and end events.<p>For modeling a discrete dynamic system with activities, we have to</p><ol><li>describe the <b>object types</b>, <b>event types</b> and <strong>activity types</strong> of the system (in an <em>information model</em>);</li><li>describe for any <strong>resource-constrained activity type</strong>, its resource roles and associated resource pools (in the <em>information model</em>);</li><li>specify, for any event type, the <b>state changes</b> of objects and the <b>follow-up events</b> caused by the occurrence of an event of that type (in a <em>process model</em>);</li><li>specify, for any activity type, the <b>state changes</b> of objects and <b>follow-up events</b> caused by start and end events of activities of that type (in the <em>process model</em>).</li></ol><section class="role-section1" id="CM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</h2><p>As our first example, we consider a basic model of a medical department of a hospital with just one type of activity, <em>medical examinations</em>, and one type of resource, <em>doctors</em>. In our second example this model is extended by adding two other resource types, <em>examination rooms</em> and <em>nurses</em>, and another type of activity: <em>walks to rooms</em> (the walks of patients to examination rooms guided by nurses).</p><section><h4>A basic conceptual model </h4><p>In our basic model of a medical department we consider just one activity, <em>medical examinations</em>, and one type of resource, <em>doctors</em>:</p><ul><li>Patients arrive at a medical department at random times.</li><li>If there are no other planned examinations waiting for the availability of a doctor, and a doctor is available, any newly arrived patient is immediately examined by that doctor. Otherwise, the planned examination of the newly arrived patient is added to a list of planned examinations (representing a queue).</li><li>The duration of examinations varies, depending on the individual case.</li><li>When an examination by a doctor is completed, the next planned examination is started by the doctor, if there is still any planned examination in the queue.</li></ul><p>The potentially relevant <b>object types</b> of the system under investigation are:</p><ul><li>patients,</li><li>medical departments,</li><li>doctors.</li></ul><p>The potentially relevant <b>event types</b> are:</p><ul><li>patient arrivals,</li><li>examination starts,</li><li>examination ends,</li></ul><p>Instead of considering the event types <em>examination starts</em> and <em>examination ends</em>, we can consider the activity type <em>examinations</em>. Thus, we get the following conceptual information model (expressed as an OEM Class Diagram, which is a special type of UML class diagram):</p><figure id="CM__figServiceDesk0"><div><img alt="???" src="tutorial_files/MedDep_CIM1.svg" width="600" /></div></figure><p>From the diagram we can infer that:</p><ul><li>For <em>patient arrivals</em> and for <em>examinations</em>, there is an association with <em>medical departments</em> providing the <em>process owner</em>, such that for any <em>patient arrival</em> event and <em>examination</em> activity a specific <em>medical department</em> is in charge of handling the event or seeing to it that the activity is going to be performed.</li><li>While <em>patient arrivals</em> have two participants: a <em>patient</em> and a <em>medical department</em>, <em>examinations</em> have three participants: a <em>patient</em>, a <em>medical department</em> and a <em>doctor</em>.</li><li><em>Examinations</em> have one resource role, <em>doctor</em>, with a resource constraint of exactly one, which means that exactly one <em>doctor</em> is required for performing an <em>examination</em>.</li><li>The process owner of an <em>examination</em>, a <em>medical department</em>, has a resource pool for <em>doctors</em>. The <em>doctors</em> needed for performing <em>examinations</em> at this department are allocated from this pool, and the department, as the process owner of <em>examinations</em>, has a business procedure for allocating <em>doctors</em> to planned <em>examinations</em> (using certain policies).</li></ul><p>In addition to a conceptual information model, which captures the system's state structure, we also need to make a conceptual process model that captures the dynamics of the system. A process model can be expressed with the help of <em>event rules</em>, which define what happens when an event (of a certain type) occurs, or, more specifically, which <em>state changes</em> and which <em>follow-up events</em> are caused by an event of that type.</p><p>The following conceptual process model (in the form of a DPMN Process Diagram) is based on the information model above. It refers to a medical department as the <em>process owner</em>, visualized in the form of a Pool container rectangle, and to <i>doctor objects</i>, as well as to the event type <i>patient arrivals</i> and to the activity type <i>examinations</i>.</p><figure><div><img alt="???" src="tutorial_files/MedDep_CPM1.svg" width="600" /></div></figure><p>This conceptual process model describes two causal regularities in the form of the following two event rules, each stated with two bullet points: one for describing the state changes and one for describing the follow-up events brought about by applying the rule.</p><ol><li><p>When a new patient arrives:</p><ul><li>if a doctor is available, then she is allocated to the examination of that patient; otherwise, a new planned examination is queued up;</li><li>if a doctor has been allocated, then start an examination of the patient.</li></ul></li><li><p>When an examination is completed by a doctor:</p><ul><li>if the queue of planned examinations is empty, then the doctor is released;</li><li>otherwise, the next planned examination by that doctor starts immediately.</li></ul></li></ol><p>Since the resource management logic in this example complies with the standard resource management procedures, we can simplify the model by using a <em>Resource-Dependent Activity Start</em> arrow between the event type circle <em>patient arrivals</em> and the activity type rectangle <em>examinations</em> for expressing the assumption of the standard resource management logic built into OES Core 2, as shown in the following DPMN process diagram: </p><figure><div><img alt="???" src="tutorial_files/MedDep_CPM1a.svg" width="300" /></div></figure></section><section><h4>An extended conceptual model </h4><p>For being more realistic, we consider the fact that patients first need to be walked by nurses to the room allocated to their examination before the examination can start. So, in our extended model of a medical department we consider two other resource types, <em>examination rooms</em> and <em>nurses</em>, and another type of activity: <em>walks to rooms</em> (the walks of patients to examination rooms guided by nurses):</p><ul><li>Patients arrive at a medical department at random times.</li><li>When a new patient arrives, and an examination room and a nurse are available, that nurse walks the patient to that room, otherwise the patient has to wait for the availability of an examination room and a nurse (administratively, a new planned walk is added to the queue/list of planned walks).</li><li>When a nurse has walked a patient to a room and a doctor is available, an examination of the patient by that doctor in the room starts; otherwise the patient has to wait for the availability of a doctor (administratively, a new planned examination is placed in the queue/list of planned examinations).</li><li><p>When an examination of a patient by a doctor in a room is completed,</p><ol><li>if there is still another planned examination of a patient waiting in a room for the availability of a doctor, the doctor goes to that room and starts the examination of that patient; otherwise, the planned examination of the newly arrived patient is added to a list of planned examinations (representing a queue);</li><li>if there is still another planned walk of a patient to a room waiting for the availability of a room, the room is allocated to this planned walk; if a nurse is available, she walks the patient to that room.</li></ol></li><li>The duration of walks and examinations varies, depending on the individual case.</li></ul><p>The potentially relevant <b>object types</b> of the system under investigation are: <em>patients</em>, <em>medical departments</em>, <em>rooms</em>, <em>nurses</em> and <em>doctors</em>.</p><p>The potentially relevant <b>event types</b> are <em>patient arrivals</em> and the activity types <em>walks to rooms</em> and <em>examinations</em>.</p><p>Thus, we get the following conceptual information model expressed as an OEM Class Diagram:</p><figure><div><img alt="???" src="tutorial_files/MedDep_CIM2.svg" width="600" /></div></figure><p>Notice that in this model, (a) the performer resource role is explicitly marked with «performer»: a <em>nurse</em> is a performer of <em>walks to rooms</em> while a <em>doctor</em> is a performer of <em>examinations</em>, and (b) the stereotypes «resource role» and «resource pool» have been abbreviated by «rr» and «rp». </p><p>From the diagram we can infer that:</p><ul><li>For the event type <em>patient arrivals</em> and for the activity types <em>walks to rooms</em> and <em>examinations</em>, there is an association with <em>medical departments</em> providing the <em>process owner</em>.</li><li>While <em>patient arrivals</em> have two participants: a <em>patient</em> and a <em>medical department</em>, <em>walks</em> and <em>examinations</em> have four participants: a <em>medical departmen</em>t, a <em>patient</em>, a <em>nurse</em> or a <em>doctor</em>, and a <em>room</em>.</li><li><em>Walks</em> have two resource roles, <em>nurse</em> and <em>room</em>, both with a resource constraint of exactly one, which means that exactly one <em>nurse</em> and one <em>room</em> are required for performing a <em>walk</em>.</li><li><em>Examinations</em> have two resource roles, <em>doctor</em> and <em>room</em>, both with a resource constraint of exactly one.</li><li>The process owner of a <em>walk to a room</em> and a subsequent <em>examination</em>, a <em>medical department</em>, has three resource pools for <em>nurses</em>, <em>rooms</em> and <em>doctors</em>. All required resources needed for performing <em>walks to room</em> and <em>examinations</em> at this department are allocated from these pools, and the department has corresponding business procedures for allocating rooms, nurses and doctors using certain allocation policies.</li></ul><p>In addition to a conceptual information model, which captures the system's state structure, we also need to make a conceptual process model that captures the dynamics of the system. A process model can be expressed with the help of event rules, which define what happens when an event (of a certain type) occurs, or, more specifically, which state changes and which follow-up events are caused by an event of that type.</p><p>The following conceptual process model (in the form of a DPMN Process Diagram) is based on the information model above. It refers to the object types <i>medical departments</i> and <i>doctors</i>, as well as to the event type <i>patient arrivals</i> and to the activity type <i>examinations</i>.</p><figure><div><img alt="???" src="tutorial_files/MedDep_CPM2.svg" width="800" /></div></figure><p>This process model describes three causal regularities in the form of the following three event rules:</p><ol><li><p>When a new patient arrives:</p><ul><li>if a room and a nurse are available, they are allocated to the walk of that patient to that room, otherwise a new planned walk is placed in the corresponding queue;</li><li>if a room has been allocated, then the nurse starts walking the patient to the room.</li></ul></li><li><p>When a walk of a patient and nurse to a room is completed:</p><ul><li>if there is still a planned walk in the queue and a room is available, then the room is allocated and the nurse is re-allocated to the walk of the next patient to that room.<br />if a doctor is available, she is allocated to the examination of that patient, else a new planned examination of that patient is queued up;</li><li>if a doctor has been allocated, then the examination of that patient starts<br />if the nurse has been re-allocated, she starts walking the next patient to the allocated room.</li></ul></li><li><p>When an examination of a patient is completed by a doctor in a particular room:</p><ul><li>if there is still a planned examination (of another patient in another room), then re-allocate the doctor to that planned examination, else release the doctor;<br />if the waiting line is not empty, re-allocate the room to the next patient, else release the room;</li><li>if the doctor has been re-allocated to a planned examination, that examination starts;<br />if the room has been re-allocated to another patient, that patient starts walking to the room.</li></ul></li></ol><p>Since, again, the resource management logic in this example complies with the standard resource management procedures built into OES Core 2, we can simplify the model by using <em>Resource-Dependent Activity Start</em> arrows resulting in an <i>Activity Network</i> model, as shown in the following DPMN process diagram:</p><figure><div><img alt="???" src="tutorial_files/MedDep_CPM2a.svg" width="500" /></div></figure></section></section><section class="role-section1" id="DesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Making Simulation Design Models</h2><p>When making a simulation design based on a conceptual model of the system under investigation, we may abstract away from certain items of the conceptual model for obtaining a sufficiently simple design. The right degree of abstraction depends on the purpose of the model.</p><p>In our example of a medical department, the purpose of the simulation model is to compute the <em>maximum queue length</em> and the <em>resource utilization</em> for all types of activities. So, we may abstract away from the object type <em>patients</em> since we don't need any information about individual patients. If we don't need utilization statistics per doctor, but only the average utilization of all doctors, then we may also abstract away from the object type <i>doctors</i> This is the approach chosen in our design models <i>Medical-Department-0</i> and <i>Medical-Department-1</i>, while we keep the object type <i>doctors</i> for modeling individual doctors in the design model <i>Medical-Department-2</i>.</p><p>Since we abstract away from individual patients, we rename <i>patient arrival</i> events to <i>NewCase</i> events, each of them representing a new case for an examination to be planned and performed.</p><p>The event type <i>NewCase</i> is a type of exogenous events,<a class="role-index-anchor" id="DesM__I__1"></a> which are not caused by any causal regularity of the system under investigation and, therefore, have to be modeled with a recurrence<a class="role-index-anchor" id="DesM__I__2"></a> function that allows to compute the time of the next occurrence of an event of that type.</p><section><h4>1.2.1. Design models based on the basic conceptual model</h4><p>We model the random variations of two variables, the recurrence of new cases and the duration of examinations, in the form of random variables<a class="role-index-anchor" id="DesM__I__3"></a> as special class-level (&quot;static&quot;) functions, with a stereotype «rv», in the class to which they belong, as shown in the diagrams below.</p><p>The recurrence of <i>NewCase</i> events is modeled as a random variable with an exponential distribution having an event rate of 0.7 per minute. The duration of examinations is modeled as a random variable with a uniform distribution having lower bound 5 and upper bound 9.</p><section><h5>The Medical-Department-1a design model</h5><p>In the <a href="https://gwagner57.github.io/oes/js/Core2/Medical-Department-1a/index.html">Medical-Department-1a</a> information design model, instead of using the built-in generic resource management logic, we explicitly model the resource management of doctors with the help of a counter variable for available doctors in the form of an attribute <i>nmrOfAvailableDoctors</i>, and the operations <i>isDoctorAvailable()</i>, <i>allocateDoctor()</i> and <i>releaseDoctor()</i>, in the <i>MedicalDepartment</i> class:</p><figure><div><img alt="???" src="tutorial_files/MedDep_CIM1-IDM1a.svg" width="500" /></div></figure><p>The <i>isDoctorAvailable</i> function simply tests if <i>nmrOfAvailableDoctors</i> &gt; 0, while the procedures <i>allocateDoctor</i> and <i>releaseDoctor</i> decrement and increment the <i>nmrOfAvailableDoctors</i> counter.</p><p>In addition to an information design model for defining the simulation's state structure, we also need to make a process design model for defining the dynamics of the simulation. The following DPMN process diagram defines two event rules:</p><figure><div><img src="tutorial_files/MedDep_CPM1-PDM0.svg" /></div></figure><p>Notice that this process design model contains the entire resource management logic for (de-)allocating doctors to (from) examinations. Since standard resource management procedures can be defined in a generic way, this logic (and the related code) can be moved from example models to the simulator, as explained in the next section.</p><p>The following table shows the two event rules defined by the above DPMN diagram, expressed in pseudo-code.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>NewCase( <i>md</i>) @ t<br />with <i>md</i> : MedicalDepartment</p></td><td><pre>newExam = new Examination( md);
<b>IF</b> md.isDoctorAvailable()
  md.allocateDoctor();
  <b>SCHEDULE</b> new <b>ActivityStart</b>( newExam);
<b>ELSE</b> 
  md.plannedExaminations.enqueue( newExam);</pre></td></tr><tr><td><p>Examination( <i>md</i>) @ t<br />with <i>md</i> : MedicalDepartment</p></td><td><pre><b>IF</b> md.plannedExaminations.length = 0
  md.releaseDoctor();
<b>ELSE</b>
  plannedExam = md.plannedExaminations.dequeue();
  <b>SCHEDULE</b> new <b>ActivityStart</b>( plannedExam);
</pre></td></tr></tbody></table></section><section><h5>The Medical-Department-1b design model</h5><p>In the <a href="https://gwagner57.github.io/oes/js/Core2/Medical-Department-1b/index.html">Medical-Department-1b</a> <em>information design</em> model we make two simplifications: </p><ol><li>We drop the object type <i>MedicalDepartment</i>; since we only need to model one medical department as the process owner, we can leave it implicit. This is a general pattern: whenever there is only one process owner, we can leave it implicit.</li><li>Since we now use the generic resource management logic that is built into <em>OES Core 2</em>, we do not need to model the methods <i>isDoctorAvailable</i>, <i>allocateDoctor</i> and <i>releaseDoctor</i>. Instead, we define a resource role doctor (with resource cardinality 1) for the activity type <i>Examination</i>.</li></ol><p>The resulting information design model only includes two classes: the event type <i>NewCase</i> and the activity type <i>Examination</i>, as shown on the left-hand side of the following class diagram.</p><figure><div><img alt="???" src="tutorial_files/MedDep_CIM1-IDM1b.svg" width="650" /></div></figure><p>On the right-hand side bottom of this diagram, the resource role <i>doctor</i> and its count pool <i>doctors</i>, instantiating the <em>OES Core 2</em> library classes <i>ResourceRole</i> and <i>CountPool</i> (as a special type of <i>ResourcePool)</i>, are shown. Notice that <u>resourceRole</u> assigns the OES resource role <i>doctor</i> with resource cardinality 1 to the activity type <i>Examination</i><a class="role-footnote-ref" href="#__FN1" id="__FNR1">[1]</a>, which is in turn linked to a count pool with name <i>doctors</i>. In OESjs-Core2, this is coded in the file <kbd>Examination.js</kbd> in the following way: </p><pre>class <b>Examination</b> extends aCTIVITY {
  constructor({id, startTime, duration}={}) {
    super({id, startTime, duration});
  }
  static <b>duration</b>() {return rand.uniform( 5, 10);}
}
Examination.<b>resourceRoles</b> = {
    &quot;doctor&quot;: {countPoolName:&quot;doctors&quot;, card:1}
}
</pre><p>The generic class-level property <i>Examination.plannedActivities</i> is automatically created by the simulator.</p><p>In the Medical-Department-1b <em>process design</em> model we make corresponding simplifications as in the information design model above:</p><ol><li>Leaving the process owner implicit, we drop the Pool rectangle <i>MedicalDepartment</i>.</li><li>Since we use the generic resource management logic that is built into <em>OES Core 2</em> by means of <em>Resource-Dependent Activity Start</em> arrows, we do not need any resource management code involving the methods <i>isDoctorAvailable</i>, <i>allocateDoctor</i> and <i>releaseDoctor</i> in event rules. Since the event rules of the Medical-Department-1a model have only be concerned with resource management, we can discard them altogether.</li></ol><p>In the resulting DPMN diagram, the event type <i>NewCase</i> is connected to the activity type <i>Examination</i> with a <em>Resource-Dependent Activity Start</em> arrow:</p><figure><div><img src="tutorial_files/MedDep_CPM1-PDM1.svg" width="350" /></div></figure>Using a <em>Resource-Dependent Activity Start</em> arrow from <i>NewCase</i> to <i>Examination</i> relieves us from coding the enqueuing of a new <i>Examination</i> activity in a <i>NewCase</i> event rule.<p>Since in this model, <i>NewCase</i> events and <i>Examination</i> activities are handled according to the generic logic of <i>Activity Networks</i> built into the <em>OES Core 2</em> simulator, we do not need to model/specify any event rules. For having <i>NewCase</i> events succeeded by <i>Examination</i> activities, we just need to specify this event flow relationship (in OESjs-Core2) in the following way:</p><pre>NewCase.<b>successorActivity</b> = &quot;Examination&quot;;</pre><p>The simulator interprets this <i>successorActivity</i> assignment when creating follow-up events for <i>NewCase</i> events by enqueuing a planned examination activity in the following way </p><pre>Examination.plannedActivities.<b>enqueue</b>( new Examination())</pre></section><section><h5>The Medical-Department-1c design model</h5><p>In the <a href="https://gwagner57.github.io/oes/js/Core2/Medical-Department-1c/index.html">Medical-Department-1c</a> design model, the resource pool <i>doctors</i> is modeled as an individual resource pool instead of a count pool. This allows making the model more realistic, for instance, by assigning an individual work schedule to each doctor defining her availability.</p><p>Compared to the Medical-Department-1b information design model, we have to change the following: </p><ol><li>We need to define an object type <i>Doctor</i> having a resource <i>status</i> attribute with the three possible values AVAILABLE, BUSY or OUT_OF_ORDER.</li><li>While we keep the <u>resourceRole</u> link with the resource role <i>doctor</i> (with resource cardinality 1), we replace the count pool linked to it with an individual resource pool.</li></ol><p>The resulting information design model is shown in the following class diagram:</p><figure><div><img alt="???" src="tutorial_files/MedDep_CIM1-IDM1c.svg" width="600" /></div></figure><p>On the right-hand side bottom of this diagram, the resource role <i>doctor</i> and its count pool <i>doctors</i>, instantiating the <em>OES Core 2</em> library classes <i>ResourceRole</i> and <i>CountPool</i> (as a special type of <i>ResourcePool)</i>, are shown. Notice that <u>resourceRole</u> assigns the OES resource role <i>doctor</i> with resource cardinality 1 to the activity type <i>Examination</i><a class="role-footnote-ref" href="#__FN2" id="__FNR2">[2]</a>, which is in turn linked to a count pool with name <i>doctors</i>. In OESjs-Core2, this is coded in the file <kbd>Examination.js</kbd> in the following way: </p><pre>class <b>Examination</b> extends aCTIVITY {
  constructor({id, startTime, duration}={}) {
    super({id, startTime, duration});
  }
  static <b>duration</b>() {return rand.uniform( 5, 10);}
}
Examination.<b>resourceRoles</b> = {
    &quot;doctor&quot;: {countPoolName:&quot;doctors&quot;, card:1}
}
</pre><p>The generic class-level property <i>Examination.plannedActivities</i> is automatically created by the simulator.</p><p>In the Medical-Department-1b <em>process design</em> model we make corresponding simplifications as in the information design model above:</p><ol><li>Leaving the process owner implicit, we drop the Pool <i>MedicalDepartment</i>.</li><li>Since we use the generic resource management logic that is built into <em>OES Core 2</em> by means of <em>Resource-Dependent Activity Start</em> arrows, we do not need any resource management code involving the methods <i>isDoctorAvailable</i>, <i>allocateDoctor</i> and <i>releaseDoctor</i> in event rules. Since the event rules of the Medical-Department-1a model have only be concerned with resource management, we can discard all of them.</li></ol><p>In the resulting DPMN diagram, the event type <i>NewCase</i> is connected to the activity type <i>Examination</i> with a <em>Resource-Dependent Activity Start</em> arrow:</p><figure><div><img src="tutorial_files/MedDep_CPM1-PDM1.svg" width="350" /></div></figure>Using a <em>Resource-Dependent Activity Start</em> arrow from <i>NewCase</i> to <i>Examination</i> relieves us from coding the enqueuing of a new <i>Examination</i> activity in a <i>NewCase</i> event rule.<p>Since in this model, <i>NewCase</i> events and <i>Examination</i> activities are handled according to the generic logic of <i>Activity Networks</i> built into the <em>OES Core 2</em> simulator, we do not need to model/specify any event rules. For having <i>NewCase</i> events succeeded by <i>Examination</i> activities, we just need to specify this event flow relationship (in OESjs-Core2) in the following way:</p><pre>NewCase.<b>successorActivity</b> = &quot;Examination&quot;;</pre><p>The simulator interprets this <i>successorActivity</i> assignment when creating follow-up events for <i>NewCase</i> events by enqueuing a planned examination activity in the following way </p><pre>Examination.plannedActivities.<b>enqueue</b>( new Examination())</pre></section></section><section><h4>1.2.2. Design models based on the extended conceptual model</h4><p>T.B.D.</p></section></section></section><section class="role-chapter" id="index-2"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Creating Activity-Based Discrete Event Simulations with OESjs-Core2</h1><p>The JavaScript-based simulator <i>OESjs-Core2</i> implements the <i>Object Event Simulation (<a href="https://sim4edu.com/OES" target="_top">OES</a>)</i> paradigm, allowing activity-based <em>Discrete Event Simulation</em> based on <i>object-oriented</i> modeling and <i>event scheduling</i>.</p><p>The code of an OESjs-Core2 simulation consists of (1) the OESjs-Core2 library files in the folder <kbd>OESjs-Core2</kbd>, (2) general library files in the <kbd>lib</kbd> folder and (3) the following files to be created by the simulation developer:</p><ol><li>For each object type <i>ObjT</i>, a JS code file <kbd>ObjT.js</kbd>.</li><li>For each event type <i>EvtT</i>, a JS code file <kbd>EvtT.js</kbd>.</li><li>For each activity type <i>ActT</i>, a JS code file <kbd>ActT.js</kbd>.</li><li>A <kbd>simulation.js</kbd> file defining further parts of the simulation, such as statistics variables and the initial state.</li></ol><p>OESjs-Core2 supports three forms of simulations:</p><ol><li><p>Standalone scenario simulations, which are good for getting a quick impression of a simulation model, e.g., by checking some simple statistics.</p></li><li><p>Simple simulation experiments, which are defined as a set of replicated simulation scenario runs, providing summary statistics like mean, standard deviation, minimum/maximum and confidence intervals for each statistics variable defined in the underlying model.</p></li><li><p>Parameter variation experiments, for which a set of experiment parameters with value sets are defined such that each experiment parameter corresponds to a model parameter. When an experiment is run, each experiment parameter value combination defines an experiment scenario, which is run repeatedly, according to the specified number or replications for collecting statistics.</p></li></ol><p>OESjs-Core2 allows defining two or more simulation scenarios for a given model. While an experiment type is defined for a given model, an experiment of that type is run on top of a specific scenario.</p><p>Using a simulation library like OESjs-Core2 means that only the model-specific logic has to be coded (in the form of object types, event types, event routines and other functions for model-specific computations), but not the general simulator operations (e.g., time progression and statistics) and the environment handling (e.g., user interfaces for statistics output).</p><p>The following sections present the basic concepts of the OESjs<i>-Core2</i> simulation library, and show how to implement the models described in <a class="role-chapter-ref" href="#index"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling of Activities</a>.</p><section class="role-section1" id="SimTime"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</h2><p>A simulation model has an underlying <b><i>time model</i></b>, which can be either <i>discrete time</i>, when setting</p><pre>sim.model.time = &quot;discrete&quot;;</pre><p>or <i>continuous time</i>, when setting</p><pre>sim.model.time = &quot;continuous&quot;;</pre><p>Choosing a discrete time model means that time is measured in steps (with equal durations), and all temporal random variables used in the model need to be discrete (i.e., based on discrete probability distributions). Choosing a continuous time model means that one has to define a <i>simulation time granularity</i>, as explained in the next sub-section.</p><p>In both cases, the underlying simulation <b><i>time unit</i></b> can be either left unspecified (e.g., in the case of an abstract time model), or it can be set to one of the time units &quot;ms&quot;, &quot;s&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;, &quot;month&quot; or &quot;year&quot;, as in</p><pre>sim.model.timeUnit = &quot;hour&quot;;</pre><p>Typical examples of time models are:</p><ol><li><p>An abstract discrete model of time where time runs in steps without any concrete meaning: </p><pre>sim.model.time = &quot;discrete&quot;;</pre></li><li><p>A concrete discrete model of time in number of days: </p><pre>sim.model.time = &quot;discrete&quot;;
sim.model.timeUnit = &quot;day&quot;;</pre></li><li><p>A concrete continuous model of time in number of seconds: </p><pre>sim.model.time = &quot;continuous&quot;;
sim.model.timeUnit = &quot;s&quot;;</pre></li></ol><section><h4>2.1.1. Time Granularity</h4><p>A model's <em>time granularity</em> is the time delay until the next moment, such that the model does not allow considering an earlier next moment. This is captured by the simulation parameter <i>nextMomentDeltaT</i> used by the simulator for scheduling immediate events with a minimal delay. When a simulation model is based on discrete time, <i>nextMomentDeltaT</i> is set to 1, referring to the next time point. When a simulation model is based on continuous time, <i>nextMomentDeltaT</i> is set to the default value 0.001, unless the model parameter <code>sim.model.nextMomentDeltaT</code> is explicitly assigned in the <kbd>simulation.js</kbd> file.</p></section><section><h4>2.1.2. Time Progression</h4><p>An important issue in simulation is the question how the simulation time is advanced by the simulator. The OES paradigm supports <strong>next-event</strong> time progression and <strong>fixed-increment</strong> time progression, as well as their combination.</p><p>An OESjs-Core1 model with fixed-increment time progression has to define a suitable periodic time event type, like <code>EachSecond</code> or <code>EachDay</code> in the form of an exogenous event type with a recurrence function returning the value 1. Such a model can be used for</p><ol><li>modeling continuous state changes (e.g., objects moving in a continuous space), or</li><li>making a discrete model that abstracts away from explicit events and uses only implicit periodic time events (&quot;ticks&quot;), which is a popular approach in social science simulation.</li></ol><p>Examples of discrete event simulation models with fixed-increment time progression and no explicit events are the <a href="https://sim4edu.com/sims/6">Schelling Segregation Model</a> and the <a href="https://sim4edu.com/sims/25/index.html">Susceptible-Infected-Recovered (SIR) Disease Model</a>.</p></section></section><section class="role-section1" id="SimModels"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</h2><section><h4>2.2.1. Model Variables and Functions</h4><p>In the simple model of a service desk discussed in the previous section, we define one (global) model variable, <i>queueLength</i>, one model function, <i>serviceTime</i>(), and two event types, as shown in the following class diagram: </p><figure><img alt="???" src="tutorial_files/IDM0.svg" width="400" /></figure><p>Notice that this model does not define any object type, which implies that the system state is not composed of the states of objects, but of the states of model variables, here it consists of the state of the model variable <i>queueLength</i>. The discrete random variable for modeling the random variation of service durations is implemented as a model function <code>serviceTime</code> shown in the <i>Global Variables and Functions</i> class. It samples integers between 2 and 4 from the empirical probability distribution <i>Frequency{ 2:0.3, 3:0.5, 4:0.2}</i>. The model can be coded with OESjs-Core1 in the following way:</p><pre>// (global) model variable
sim.model.v.<strong>queueLength</strong> = 0;
// (global) model function
sim.model.f.<strong>serviceTime</strong> = function () {
  var r = math.getUniformRandomInteger( 0, 99);
  if ( r &lt; 30) return 2;         // probability 0.30
  else if ( r &lt; 80) return 3;    // probability 0.50
  else return 4;                 // probability 0.20
};</pre><p>You can <a href="https://gwagner57.github.io/oes/js/Core1/Service-Desk-0/index.html" target="_top">run this Service-Desk-0 model</a> from the project's GitHub website. An example of a run of this model is shown in the following simulation log: </p><table border="1" id="SimModels__lot__1"><caption><span class="role-label">Table <span class="role-number">2-1</span>. </span>Simulation Log</caption><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody id="SimModels__simLog"><tr><td>0</td><td>0</td><td>queueLength: 0</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>queueLength: 1</td><td>CustomerDeparture@4, CustomerArrival@4</td></tr><tr><td>2</td><td>4</td><td>queueLength: 1</td><td>CustomerDeparture@6, CustomerArrival@7</td></tr><tr><td>3</td><td>6</td><td>queueLength: 0</td><td>CustomerArrival@7</td></tr><tr><td>4</td><td>7</td><td>queueLength: 1</td><td>CustomerDeparture@11, CustomerArrival@13</td></tr><tr><td>5</td><td>11</td><td>queueLength: 0</td><td>CustomerArrival@13</td></tr><tr><td>6</td><td>13</td><td>queueLength: 1</td><td>CustomerDeparture@15, CustomerArrival@19</td></tr><tr><td>7</td><td>15</td><td>queueLength: 0</td><td>CustomerArrival@19</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>49</td><td>114</td><td>queueLength: 0</td><td>CustomerArrival@117</td></tr><tr><td>50</td><td>117</td><td>queueLength: 1</td><td>CustomerArrival@118, CustomerDeparture@119</td></tr><tr><td>51</td><td>118</td><td>queueLength: 2</td><td>CustomerDeparture@119, CustomerArrival@119</td></tr><tr><td>52</td><td>119</td><td>queueLength: 2</td><td>CustomerArrival@121, CustomerDeparture@123</td></tr><tr><td>53</td><td>121</td><td>queueLength: 3</td><td>CustomerDeparture@123, CustomerArrival@124</td></tr><tr><td>54</td><td>123</td><td>queueLength: 2</td><td>CustomerArrival@124, CustomerDeparture@126</td></tr><tr><td>55</td><td>124</td><td>queueLength: 3</td><td>CustomerArrival@125, CustomerDeparture@126</td></tr><tr><td>56</td><td>125</td><td>queueLength: 4</td><td>CustomerDeparture@126, CustomerArrival@128</td></tr><tr><td>57</td><td>126</td><td>queueLength: 3</td><td>CustomerArrival@128, CustomerDeparture@128</td></tr><tr><td>58</td><td>128</td><td>queueLength: 3</td><td>CustomerArrival@129, CustomerDeparture@131</td></tr><tr><td>59</td><td>129</td><td>queueLength: 4</td><td>CustomerDeparture@131, CustomerArrival@133</td></tr><tr><td>60</td><td>131</td><td>queueLength: 3</td><td>CustomerArrival@133, CustomerDeparture@135</td></tr><tr><td>61</td><td>133</td><td>queueLength: 4</td><td>CustomerDeparture@135, CustomerArrival@137</td></tr><tr><td>62</td><td>135</td><td>queueLength: 3</td><td>CustomerArrival@137, CustomerDeparture@137</td></tr><tr><td>63</td><td>137</td><td>queueLength: 3</td><td>CustomerArrival@139, CustomerDeparture@141</td></tr><tr><td>64</td><td>139</td><td>queueLength: 4</td><td>CustomerDeparture@141, CustomerArrival@142</td></tr><tr><td>65</td><td>141</td><td>queueLength: 3</td><td>CustomerArrival@142, CustomerDeparture@144</td></tr><tr><td>66</td><td>142</td><td>queueLength: 4</td><td>CustomerDeparture@144, CustomerArrival@147</td></tr><tr><td>67</td><td>144</td><td>queueLength: 3</td><td>CustomerArrival@147, CustomerDeparture@148</td></tr><tr><td>68</td><td>147</td><td>queueLength: 4</td><td>CustomerDeparture@148, CustomerArrival@148</td></tr><tr><td>69</td><td>148</td><td>queueLength: 4</td><td>CustomerArrival@149, CustomerDeparture@151</td></tr><tr><td>70</td><td>149</td><td>queueLength: 5</td><td>CustomerDeparture@151, CustomerArrival@151</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table></section><section><h4>2.2.2. Object Types</h4><p>Object types are defined in the form of classes. Consider the object type <i>ServiceDesk</i> defined in the following <i>Service-Desk-1</i> model: </p><figure><img alt="???" src="tutorial_files/IDM1.svg" width="400" /></figure><p>While <code>queueLength</code> was defined as a global variable in the <i>Service-Desk-0</i> model, it is now defined as an attribute of the object type <i>ServiceDesk</i>:</p><pre>class <b>ServiceDesk</b> extends oBJECT {
  constructor({ id, name, queueLength}) {
    super( id, name);
    this.<b>queueLength</b> = queueLength;
  }
  static <b>serviceTime</b>() {
    var r = math.getUniformRandomInteger( 0, 99);
    if ( r &lt; 30) return 2;         // probability 0.3
    else if ( r &lt; 80) return 3;    // probability 0.5
    else return 4;                 // probability 0.2
  }
}
ServiceDesk.<b>labels</b> = {&quot;queueLength&quot;:&quot;qLen&quot;};  // for the log</pre><p>Notice that, in OESjs, object types are defined as subtypes of the pre-defined class <code>oBJECT</code>, from which they inherit an integer-valued <code>id</code> attribute and an optional <code>name</code> attribute. When a property has a <code>label</code> (defined by the class-level (map-valued) property <code>labels</code>), it is shown in the simulation log.</p><p>You can <a href="https://gwagner57.github.io/oes/js/Core1/Service-Desk-1/index.html" target="_top">run this <i>simulation</i> model</a> from the project's GitHub website.</p></section><section><h4>2.2.3. Event Types</h4><p>In OES, there is a distinction between two kinds of events:</p><ol><li>events that are <em>caused</em> by other event occurrences during a simulation run;</li><li><em>exogenous</em> events that seem to happen spontaneously, but may be caused by factors, which are external to the simulation model.</li></ol><p>Here is an example of an exogenous event type definition in OESjs-Core1:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.<b>serviceDesk</b> = serviceDesk;
  }
  onEvent() {
    ...
  }
  createNextEvent() {
    ...
  }
  static recurrence() {
    ...
  }
}</pre><p>The definition of the <i>CustomerArrival</i> event type includes a reference property <i>serviceDesk</i>, which is used for referencing the service desk object at which a customer arrival event occurs. In OESjs, event types are defined as subtypes of the pre-defined class <code>eVENT</code>, from which they inherit an attribute <code>occTime</code>, which holds the occurrence time<a class="role-index-anchor" id="SimModels__I__4"></a> of an event. As opposed to objects, events do normally not have an ID, nor a name. </p><p>Each event type needs to define an <code>onEvent</code> method that implements the event rule for events of the defined type. Event rules are discussed below. </p><p>Exogenous events occur periodically. They are therefore defined with a <em>recurrence</em> function,<a class="role-index-anchor" id="SimModels__I__5"></a> which provides the time in-between two events (often in the form of a random variable). The recurrence function is defined as a class-level (&quot;static&quot;) method:</p><pre>class CustomerArrival extends eVENT {
  ...
  static <b>recurrence</b>() {
    return math.getUniformRandomInteger( 1, 6);
  }
}</pre><p>Notice that the <i>recurrence</i> function of <i>CustomerArrival</i> is coded with the library method <code class="code">math.getUniformRandomInteger</code>, which allows sampling from discrete uniform probability distribution functions. </p><p>In the case of an exogenous event type definition, a <i>createNextEvent</i> method has to be defined for assigning event properties and returning the next event of that type, which is scheduled by invoking the <i>recurrence</i> function for setting its <i>ocurrenceTime</i> and by copying all participant references (such as the <i>serviceDesk</i> reference). </p><pre>class CustomerArrival extends eVENT {
  ...
  <b>createNextEvent</b>() {
    return new CustomerArrival({
      occTime: this.occTime + CustomerArrival.<b>recurrence</b>(),
      serviceDesk: this.serviceDesk
    });
  }
}</pre><p>The second event type of the <i>Service-Desk-1</i> model, <i>Departure</i>, is an example of a type of <i>caused</i> events:</p><pre>class <b>CustomerDeparture</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.serviceDesk = serviceDesk;
  }
  onEvent() {
    ...
  }
}</pre></section><section><h4>2.2.4. Event Rules</h4><p>An event rule<a class="role-index-anchor" id="SimModels__I__6"></a> for an event type defines what happens when an event of that type occurs, by specifying the caused state changes and follow-up events. In OESjs, event rules are coded as <code>onEvent</code> methods of the class that implements the event type. These methods return a set of events (more precisely, a set of JS objects representing events).</p><p>Notice that in the DES literature, event rule methods are called <i>event routines</i><a class="role-index-anchor" id="SimModels__I__7"></a>.</p><p>For instance, in the <code>CustomerArrival</code> class, the following event rule method is defined:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // increment queue length due to newly arrived customer
    this.serviceDesk.<b>queueLength</b>++;
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    // if the service desk is not busy
    if (this.serviceDesk.queueLength === 1) {
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre><p>The context of this event rule method is the event that triggers the rule, that is, the variable <code>this</code> references a JS object that represents the triggering event. Thus, the expression <code>this.serviceDesk</code> refers to the service desk object associated with the current customer arrival event, and the statement <code>this.serviceDesk.queueLength++</code> increments the <i>queueLength</i> attribute of this service desk object (as an immediate state change).</p><p>The following event rule method is defined in the <code>CustomerDeparture</code> class. </p><pre>class <b>CustomerDeparture</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // decrement queue length due to departure
    this.serviceDesk.<b>queueLength</b>--;
    // update statistics
    sim.stat.<b>departedCustomers</b>++;
    // if there are still customers waiting
    if (this.serviceDesk.queueLength &gt; 0) {
      // start next service and schedule its end/departure
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre></section><section><h4>2.2.5. Event Priorities</h4><p>An OES model may imply the possibility of several events occurring at the same time. Consequently, a simulator (like OESjs) must be able to process simultaneous events.<a class="role-index-anchor" id="SimModels__I__8"></a> In particular, simulation models based on discrete time may create simulation states where two or more events occur at the same time, but the model's logic requires them to be processed in a certain order. Defining priorities for events of a certain type helps to control the processing order of simultaneous events.</p><p>Consider an example model based on discrete time with three exogenous event types <i>StartOfMonth</i>, <i>EachDay</i> and <i>EndOfMonth</i>, where the recurrence of StartOfMonth and EndOfMonth is 21, and the recurrence of EachDay is 1. In this example we want to control that on simulation time 1 + <i>i</i> * 21 both a StartOfMonth and an EachDay event occur simultaneously, but StartOfMonth should be processed before EachDay, and on simulation time 21 + <i>i</i> * 21 both an EndOfMonth and an EachDay event occur simultaneously, but EndOfMonth should be processed after EachDay. This can be achieved by defining a high priority, say 2, to StartOfMonth, a middle priority, say 1, to StartOfMonth, and a low priority, say 0, to EndOfMonth. </p><p>Event priorities are defined as class-level properties of event classes in the event type definition file. Thus, we would define in <kbd>StartOfMonth.js</kbd>:</p><pre>StartOfMonth.priority = 2;</pre><p>and in <kbd>EachDay.js</kbd>:</p><pre>EachDay.priority = 1;</pre><p>and finally in <kbd>EndOfMonth.js</kbd>:</p><pre>EndOfMonth.priority = 0;</pre></section><section><h4>2.2.6. Library Methods for Sampling Probability Distribution Functions</h4><p>Random variables<a class="role-index-anchor" id="SimModels__I__9"></a> are implemented as methods that sample specific <em>probability distribution functions (PDFs)</em>.<a class="role-index-anchor" id="SimModels__I__a"></a> Simulation frameworks typically provide a library of predefined parametrized PDF sampling methods, which can be used with one or several (possibly seeded) streams of <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_top">pseudo-random numbers</a>.</p><p>The OESjs simulator provides the following predefined parametrized PDF sampling methods:</p><table border="1"><thead><tr><td style="text-align:center;"><b>Probability Distribution Function</b></td><td style="text-align:center;"><b>OESjs Library Method</b></td><td style="text-align:center;"><b>Example</b></td></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_top">Uniform</a></td><td><code>uniform</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>rand.uniform( 0.5, 1.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution" target="_top">Discrete Uniform</a></td><td><code>uniformInt</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>rand.uniformInt( 1, 6)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Triangular</a></td><td><code>triangular</code>( <i>lowerBound</i>, <i>upperBound</i>, <i>mode</i>)</td><td><code>rand.triangular( 0.5, 1.5, 1.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Frequency</a></td><td><code>frequency</code>( <i>frequencyMap</i>)</td><td><code>rand.frequency({&quot;2&quot;:0.4, &quot;3&quot;:0.6})</code></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Exponential_distribution" target="_top">Exponential</a></td><td><code>exponential</code>( <i>eventRate</i>)</td><td><code>rand.exponential( 0.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Gamma_distribution" target="_top">Gamma</a></td><td><code>gamma</code>( <i>shape</i>, <i>scale</i>)</td><td><code>rand.gamma( 1.0, 2.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Normal_distribution" target="_top">Normal</a></td><td><code>normal</code>( <i>mean</i>, <i>stdDev</i>)</td><td><code>rand.normal( 1.5, 0.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Pareto_distribution" target="_top">Pareto</a></td><td><code>pareto</code>( <i>shape</i>)</td><td><code>rand.pareto( 2.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Weibull_distribution" target="_top">Weibull</a></td><td><code>weibull</code>( <i>scale</i>, <i>shape</i>)</td><td><code>rand.weibull( 1, 0.5)</code></td></tr></tbody></table><p>The OESjs library <kbd>rand.js</kbd> supports both unseeded and seeded random number streams.<a class="role-index-anchor" id="SimModels__I__b"></a> By default, its PDF sampling methods are based on an unseeded stream, using Marsaglia’s high-performance random number generator <a href="https://en.wikipedia.org/wiki/Xorshift" target="_top"><em>xorshift</em></a> that is built into the <code>Math.random</code> function of modern JavaScript engines.</p><p>A seeded random number stream, based on the slower <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_top">Mersenne Twister</a> algorithm, can be obtained by setting the scenario parameter <code>sim.scenario.randomSeed</code> to a positive integer value.</p><p>Additional streams can be defined and used in the following way:</p><pre>var stream1 = new Random( 1234);
var stream2 = new Random( 6789);
var service1Duration = stream1.exponential( 0.5);
var service2Duration = stream2.exponential( 1.5);</pre><p><b>Warning</b>: Avoid using JavaScript's built-in <code>Math.random</code> in simulation code. Always use <code>rand.uniform</code>, or one of the other probability distribution functions from the <i>rand</i> library described above, for generating random numbers.</p></section></section><section class="role-section1" id="SimScenarios"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</h2><p>For obtaining a complete executable simulation scenario, a simulation model has to be complemented with <em>simulation parameter settings</em> and an <em>initial system state</em>.</p><p>In general, we may have more than one simulation scenario for a simulation model. For instance, the same model could be used in two different scenarios with different initial states. </p><p>An OESjs <em>simulation scenario</em> consists of</p><ol><li>a simulation model;</li><li>simulation parameter settings, such as setting a value for <code>durationInSimTime</code> and <code>randomSeed</code>; and</li><li>an initial state definition.</li></ol><p>An empty template for the <kbd>simulation.js</kbd> file has the following structure:</p><pre>// ***** Simulation Model *******************
sim.model.time = &quot;...&quot;;  // discrete or continuous
sim.model.timeIncrement = ...;   // optional
sim.model.timeUnit = &quot;...&quot;;  // optional (ms|s|min|hour|day|week|month|year)
sim.model.v.aModelVariable = ...;  // (developer-defined) model variables
sim.model.f.aModelFunction = ...;  // (developer-defined) model functions
<b>sim.model.p.aModelParameter = ...;  // (developer-defined) model parameters</b>
sim.model.objectTypes = [...];  // (developer-defined) object types
sim.model.eventTypes = [...];  // (developer-defined) event types
// ***** Simulation Parameters **************
sim.scenario.durationInSimTime = ...;
sim.scenario.randomSeed = ...;    // optional
// ***** Initial State **********************
sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // Create initial objects
  ...
  // Schedule initial events
  ...
};
// ***** Ex-Post Statistics *****************
sim.model.statistics = {...};</pre><p>We briefly discuss each group of scenario information items in the following sub-sections.</p><section><h4>2.3.1. Model Parameters</h4><p>While model variables are state variables whose values are changed as an effect of an event occurrence, <em>model parameters</em> are not part of the dynamic state of the simulated system, but are rather used for providing values that can only be read during a simulation run. The main purpose of model parameters is to allow <em>parameter variation experiments</em>.</p></section><section><h4>2.3.2. Simulation Scenario Parameters</h4><p>A few simulation parameters are predefined as attributes of the simulation scenario. The most important ones are:</p><ul><li><i>durationInSimTime</i> - this attribute allows defining the duration of a simulation run; which runs forever when this attribute s not set;</li><li><i>randomSeed</i>: Setting this optional parameter to a positive integer allows to obtain a specific fixed random number sequence (generated by a random number generator). This can be used for performing simulation runs with the same (repeated) random number sequence, e.g., for testing a simulation model by checking if expected results are obtained.</li></ul></section><section id="SimScenarios__sectInitialState"><h4>2.3.3. Initial State</h4><p>Defining an initial state means:</p><ol><li>assigning initial values to global model variables, if there are any;</li><li>defining which objects exist initially, and assigning initial values to their properties;</li><li>defining which events are scheduled initially.</li></ol><p>A <code>setupInitialState</code> procedure takes care of these initial state definitions. A global model variable is initialized in the following way: </p><pre>sim.scenario.setupInitialState = function () {
  // <b>Initialize model variables</b>
  <b>sim.model.v.queueLength</b> = 0;
  // Create initial objects
  ...
  // Schedule initial events
  ...
};</pre><p>An initial state object is created by instantiating an object type of the simulation model with suitable initial property values, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // <b>Create initial objects</b>
  let <b>serviceDesk1</b> = new ServiceDesk({id: 1, queueLength: 0});
  // Schedule initial events
  ...
};</pre><p>Notice that object IDs are positive integers, but when used as keys in the map <code>sim.objects</code>, they are converted to strings.</p><p>Instead of assigning a <strong>fixed value</strong> to a property like <code>queueLength</code> for defining an object's initial state, as in <code>queueLength: 0</code>, we can also assign it a <strong>fixed expression</strong>, as in <code>queueLength: Math.round(12/30)</code>.</p><p>An <strong>initial event</strong> is scheduled by adding it to the <em>Future Events List (FEL)</em>, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // Create initial objects
  let desk1 = new ServiceDesk({id: 1, queueLength: 0});
  // <b>Schedule initial events</b>
  sim.<b>FEL.add</b>( <b>new CustomerArrival</b>({occTime:1, serviceDesk: desk1}));
};</pre><p>Initial objects or events can be parametrized with the help of model parameters.</p></section><section><h4>2.3.4. Defining Alternative Scenarios with Different Initial States</h4><p>For running a model on top of different initial states, one can define a list of scenarios, each with its own <code>setupInitialState</code> procedure: </p><pre>sim.<b>scenarios[1]</b> = {
  scenarioNo: 1,
  title: &quot;Scenario with two service desks&quot;,
  setupInitialState: function () {
    // Create initial objects
    var sD1 = new ServiceDesk({id: 1, queueLength: 0}),
        sD2 = new ServiceDesk({id: 2, queueLength: 0});
    // Schedule initial events
    sim.FEL.add( new CustomerArrival({occTime: 1, serviceDesk: sD1}));
    sim.FEL.add( new CustomerArrival({occTime: 2, serviceDesk: sD2}));
  }
};
sim.<b>scenarios[2]</b> = {...}</pre><p>Before running a simulation, a specific scenario can be chosen in the user interface.</p><blockquote class="role-warning"><p>Do not set model parameters in the <code>setupInitialState</code> procedure! This would interfere with parameter variation experiments in which the same parameter(s) are used.</p></blockquote></section></section><section class="role-section1" id="SimStatistics"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</h2><p>In scientific and engineering simulation projects the main goal is getting estimates of the values of certain variables or performance indicators with the help of statistical methods. In educational simulations, statistics can be used for observing simulation runs and for learning the dynamics of a simulation model. </p><p>For collecting statistics, suitable <em>statistics variables</em> have to be defined, as in the following example:</p><pre>sim.model.<b>setupStatistics</b> = function () {
  sim.stat.arrivedCustomers = 0;
  sim.stat.departedCustomers = 0;
  sim.stat.maxQueueLength = 0;
};</pre><p>Statistics variables have to be updated in <i>onEvent</i> methods. For instance, the variables <i>arrivedCustomers</i> and <i>maxQueueLength</i> are updated in the onEvent method of the <i>CustomerArrival</i> event class:</p><pre>class CustomerArrival extends eVENT {
  ...
  onEvent() {
    ...
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    ...
  }
}</pre><p>In certain cases, a statistics variable can only be computed at the end of a simulation run. For this purpose, there is the option to define a <i>computeFinalStatistics</i> procedure:</p><pre>sim.model.<b>computeFinalStatistics</b> = function () {
  // percentage of business days without stock-outs
  sim.stat.serviceLevel = (sim.time - sim.stat.nmrOfStockOuts) / sim.time * 100;
};</pre><p>After running a simulation scenario, the statistics results are shown in a table:</p><table border="1" id="SimStatistics__lot__2"><caption><span class="role-label">Table <span class="role-number">2-2</span>. </span>Statistics</caption><tbody><tr><td>arrivedCustomers</td><td>289</td></tr><tr><td>departedCustomers</td><td>288</td></tr><tr><td>maxQueueLength</td><td>4</td></tr></tbody></table></section><section class="role-section1" id="SimExperiments"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</h2><p>There are different types of simulation experiments. In a <em>simple experiment</em>, a simulation scenario is run repeatedly by defining a number of replications (iterations) for being able to compute average statistics.</p><p>In a <em>parameter variation experiment</em>, several variants of a simulation scenario (called <em>experiment scenarios</em>), are defined by defining value sets for certain <em>model parameters</em> (the <em>experiment parameters</em>), such that a parameter variation experiment run consists of a set of experiment scenario runs, one for each combination of parameter values.</p><p>An experiment type is defined for a given simulation model and an experiment of that type is run on top of a given simulation scenario for that model.</p><p>When running an experiment, the resulting statistics data are stored in a database, which allows looking them up later on or exporting them to data analysis tools (such as Microsoft Excel and RStudio)</p><section><h4>2.6.1. Simple Experiments</h4><p>A simple experiment type is defined with a <code>sim.experimentType</code> record on top of a model by defining (1) the number of <em>replications</em> and (2) possibly a list of <em>seed values</em>, one for each replication. The following code shows an example of a simple experiment type definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experimentType = {
  title: &quot;Simple Experiment with 10 replications, each running for 1000 time units (days)&quot;,
  nmrOfReplications: 10,
  seeds: [123, 234, 345, 456, 567, 678, 789, 890, 901, 1012]
};</pre></td></tr></tbody></table><p>Running this simple experiment means running the underlying scenario 10 times, each time with another random seed, as specified by the list of seeds. The resulting statistics are composed of the statistics for each replication complemented with a summary statistics listing averages, standard deviations, min/max values and confidence intervals.</p><p>When no seeds are defined, the experiment is run with implicit random seeds using JavaScript's built-in random number generator, which implies that experiment runs are not reproducible.</p></section><section><h4>2.6.2. Parameter Variation Experiments</h4><p>A parameter variation experiment is defined with (1) a number of <em>replications</em>, (2) a list of <em>seed values</em> (one for each replication), and (3) one or more experiment parameters. </p><p>An experiment parameter must have the same name as the model parameter to which it refers. It defines a set of values for this model variable, either using a <code>values</code> field or a combination of a <code>startValue</code> and <code>endValue</code> field (and <code>stepSize</code> for a non-default increment value) as in the following example.</p><p>The following code shows an example of a parameter variation experiment definition (on top of the <a href="https://gwagner57.github.io/oes/js/Core1/Inventory-Management/index.html">Inventory-Management</a> simulation model):</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experimentTypes[1] = {
  id: 1,
  title: &quot;Parameter variation experiment for exploring reorderInterval and targetInventory&quot;,
  nmrOfReplications: 10,
  seeds: [123, 234, 345, 456, 567, 678, 789, 890, 901, 1012],
  <b>parameterDefs</b>: [
    {name:&quot;reviewPolicy&quot;, values:[&quot;periodic&quot;]},
    {name:&quot;reorderInterval&quot;, values:[2,3,4]},
    {name:&quot;targetInventory&quot;, startValue:80, endValue:100, stepSize:10},
  ]
};</pre></td></tr></tbody></table><p>Notice that this experiment definition defines 9 experiment scenarios resulting from the combinations of the values 2/3/4 and 80/90/100 for the parameters <i>reorderInterval</i> and <i>targetInventory</i>. Running this parameter variation experiment means running each of the 9 experiment scenarios 10 times (each time with another random seed, as specified by the list of seeds). The resulting statistics, as shown in the following table, is computed by averaging all statistics variables defined for the given model. </p><table border="1" class="expStatistics" id="SimExperiments__simLogTbl"><thead><tr><th colspan="5">Experiment Results</th></tr><tr><th rowspan="2">Experiment scenario</th><th rowspan="2">Parameter values</th><th colspan="3">Statistics</th></tr><tr><th>nmrOfStockOuts</th><th>lostSales</th><th>serviceLevel</th></tr></thead><tbody id="SimExperiments__simLog"><tr><td>0</td><td>periodic,2,80</td><td>21.8</td><td>180.7</td><td>97.82</td></tr><tr><td>1</td><td>periodic,2,90</td><td>7.4</td><td>55.9</td><td>99.26</td></tr><tr><td>2</td><td>periodic,2,100</td><td>2.1</td><td>15.8</td><td>99.79</td></tr><tr><td>3</td><td>periodic,3,80</td><td>86.6</td><td>855.6</td><td>91.34</td></tr><tr><td>4</td><td>periodic,3,90</td><td>40.6</td><td>377.5</td><td>95.94</td></tr><tr><td>5</td><td>periodic,3,100</td><td>16.3</td><td>139.8</td><td>98.37</td></tr><tr><td>6</td><td>periodic,4,80</td><td>171.5</td><td>2067.5</td><td>82.85</td></tr><tr><td>7</td><td>periodic,4,90</td><td>110.6</td><td>1238.3</td><td>88.94</td></tr><tr><td>8</td><td>periodic,4,100</td><td>63.8</td><td>661.4</td><td>93.62</td></tr></tbody></table></section><section><h4>2.6.1. Storage and Export of Experiment Results</h4><p>In OESjs-Core1, an experiment's output statistics data is stored in a browser-managed database using JavaScript's <em>IndexedDB</em> technology. The name of this database is the same as the name of the simulation model. It can be inspected with the help of the browser's developer tools, which are typically activated with the key combination [Shift]+[Ctrl]+[I]. For instance, in Google's <em>Chrome</em> browser, one has to go to Application/Storage/IndexedDB.</p><p>The experiment statistics database consists of three tables containing data about (1) experiment runs, (2) experiment scenarios, and (3) experiment scenario runs, which can be exported to a CSV file. </p><section></section></section></section><section class="role-section1" id="SimLog"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</h2><p>The OESjs-Core1 simulator can generate a simulation log, which allows to inspect the evolving states of a simulation run. Inspecting the simulation log can help to understand the dynamics of a model, or it can be used for finding logical flaws in it.</p><p>The contents of the simulation log can be controlled by defining <em>labels</em> for those object properties that are to be displayed in the log. For instance, in the case of the <a href="https://gwagner57.github.io/oes/js/Core1/Service-Desk-1/index.html" target="_top">Service-Desk-1</a> model, a label &quot;qLen&quot; is defined for the <code>queueLength</code> property of <i>ServiceDesk</i> objects by setting</p><pre>ServiceDesk.labels = {&quot;queueLength&quot;:&quot;qLen&quot;};</pre><p> This results in the following simulation log:</p><table border="1"><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Service-Desk-1{ qLen: 0}</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerDeparture@5, CustomerArrival@6</td></tr><tr><td>2</td><td>5</td><td>Service-Desk-1{ qLen: 0}</td><td>CustomerArrival@6</td></tr><tr><td>3</td><td>6</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerArrival@7, CustomerDeparture@10</td></tr><tr><td>4</td><td>7</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerDeparture@10, CustomerArrival@10</td></tr><tr><td>5</td><td>10</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerArrival@12, CustomerDeparture@13</td></tr><tr><td>6</td><td>12</td><td>Service-Desk-1{ qLen: 3}</td><td>CustomerDeparture@13, CustomerArrival@16</td></tr><tr><td>7</td><td>13</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerArrival@16, CustomerDeparture@16</td></tr><tr><td>8</td><td>16</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerDeparture@19, CustomerArrival@21</td></tr><tr><td>9</td><td>19</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerArrival@21, CustomerDeparture@23</td></tr></tbody></table></section></section><section class="role-appendix" id="architecture"><h1 class="role-appendix-title"><span class="role-label">Appendix <span class="role-number">A</span>. </span>Simulator Architecture</h1><p>OES Core 2 adds the following features to OES Core 1:</p><ul><li>activities as composite events, having a start event and an end event, and a duration as the time in-between their start and end events</li><li>resource roles with resource constraints</li><li>resource pools</li><li>automated (a) throughput, (b) queue length, (c) cycle time, and (d) resource utilization statistics per activity type</li></ul><p>The OES Core 2 simulator's information architecture is described by the following class diagram:</p><figure><img src="tutorial_files/OES-Core2.svg" /></figure></section><div class="role-backmatter" id="backmatter"><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1><nav class="role-index-toc" id="__I_TOC"><span class="role-index-toc-placeholder">A</span> <span class="role-index-toc-placeholder">B</span> <span class="role-index-toc-placeholder">C</span> <span class="role-index-toc-placeholder">D</span> <a class="role-index-div-ref" href="#__I_TOC_E">E</a> <span class="role-index-toc-placeholder">F</span> <span class="role-index-toc-placeholder">G</span> <span class="role-index-toc-placeholder">H</span> <span class="role-index-toc-placeholder">I</span> <span class="role-index-toc-placeholder">J</span> <span class="role-index-toc-placeholder">K</span> <span class="role-index-toc-placeholder">L</span> <span class="role-index-toc-placeholder">M</span> <span class="role-index-toc-placeholder">N</span> <a class="role-index-div-ref" href="#__I_TOC_O">O</a> <a class="role-index-div-ref" href="#__I_TOC_P">P</a> <span class="role-index-toc-placeholder">Q</span> <a class="role-index-div-ref" href="#__I_TOC_R">R</a> <a class="role-index-div-ref" href="#__I_TOC_S">S</a> <span class="role-index-toc-placeholder">T</span> <span class="role-index-toc-placeholder">U</span> <span class="role-index-toc-placeholder">V</span> <span class="role-index-toc-placeholder">W</span> <span class="role-index-toc-placeholder">X</span> <span class="role-index-toc-placeholder">Y</span> <span class="role-index-toc-placeholder">Z</span></nav><div class="role-index-div" id="__I_TOC_E"><h2 class="role-index-div-title">E<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I6"><span class="role-index-term">event routine</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__7">1</a></span></li><li class="role-index-entry" id="__I5"><span class="role-index-term">event rule</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__6">1</a></span></li><li class="role-index-entry" id="__I1"><span class="role-index-term">exogenous event</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__1">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_O"><h2 class="role-index-div-title">O<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I4"><span class="role-index-term">occurrence time</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__4">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_P"><h2 class="role-index-div-title">P<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I8"><span class="role-index-term">probability distribution function</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__a">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_R"><h2 class="role-index-div-title">R<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I9"><span class="role-index-term">random number stream</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__b">1</a></span></li><li class="role-index-entry" id="__I3"><span class="role-index-term">random variable</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__3">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__9">2</a></span></li><li class="role-index-entry" id="__I2"><span class="role-index-term">recurrence</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__2">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__5">2</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_S"><h2 class="role-index-div-title">S<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I7"><span class="role-index-term">simultaneous events</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__8">1</a></span></li></ul></div></section></div></section><div class="role-footnotes"><hr class="role-footnote-separator" /><div class="role-footnote" id="__FN1"><a class="role-footnote-number" href="#__FNR1">[1]</a> Such a resource role assignment is expressed in the UML class diagram as a link instantiating the corresponding class-level meta-property <i>ActivityType.resourceRole</i>.</div><div class="role-footnote" id="__FN2"><a class="role-footnote-number" href="#__FNR2">[2]</a> Such a resource role assignment is expressed in the UML class diagram as a link instantiating the corresponding class-level meta-property <i>ActivityType.resourceRole</i>.</div></div></body></html>