<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Tutorial: Discrete Event Simulation with OESjs-Core1</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="tutorial_files/ebook.css" rel="stylesheet" type="text/css" /><meta content="OES" name="og:site_name" /><meta content="Tutorial: Discrete Event Simulation with OESjs-Core1" name="og:title" /><meta content="en" name="og:locale" /><meta content="This tutorial article explains how to use the OESjs-Core1 simulation library, which implements an architecture for Object Event Simulation (OES), extending the OESjs Core 0 simulator by adding fixed-increment time progression, a seedable random number generator, a set of sampling functions from various probability distributions (uniform, triangular, normal, exponential, etc.), multiple scenarios per model, multiple experiment types per model, model parameters, parameter variation experiments, as well as persistent storage and export of experiment results." name="og:description" /><meta content="https://gwagner57.github.io/oes/js/Core1/tutorial.html" name="og:url" /><meta content="https://sim4edu.com/img/sim4edu.png" name="og:image" /><meta content="summary_large_image" name="twitter:card" /><style>/*<![CDATA[*/
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
table.expStatistics tbody td {
    text-align: right;
}

div.role-book-title-div h1.role-book-title {
    margin-bottom: 0.33em;
}
div[id$="subtitle"] {
    margin-top: 0.33em;
}


div#share {
    display: block; /*inline-block*/
}
ul.links {
    list-style: none;
    padding: 0;
    margin: 0 0 0 1em;
}
ul.links li {
    display: inline;
    text-align: center;
    cursor: pointer;
    margin-right: 1em;
}
ul.links li:hover {
    text-decoration: underline;
}
.icon-social {
    width: 20px;
    height: 20px;
    background: #eee;
}/*]]>*/</style></head><body><section class="role-book" id="tutorial"><div class="role-book-title-div"><h1 class="role-book-title">Tutorial: Discrete Event Simulation with OESjs-Core1</h1><div class="role-content" id="tutorial-content-1"><div id="tutorial-content-1__share"> <ul class="links"><li class="share facebook" title="Share on Facebook"><a href="https://www.facebook.com/sharer.php?u=https://gwagner57.github.io/oes/js/Core1/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-facebook" viewBox="0 0 18 18"><path d="M15.7,1.5H2.3c-0.5,0-0.8,0.4-0.8,0.8v13.3c0,0.5,0.4,0.8,0.8,0.8h7.2v-5.8h-2V8.4h2V6.8c0-1.9,1.2-3,2.9-3 c0.8,0,1.5,0.1,1.7,0.1v2l-1.2,0c-0.9,0-1.1,0.4-1.1,1.1v1.4h2.2l-0.3,2.3h-1.9v5.8h3.8c0.5,0,0.8-0.4,0.8-0.8V2.3 C16.5,1.9,16.1,1.5,15.7,1.5z"></path></symbol> <use xlink:href="#social-facebook" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share twitter" title="Share on Twitter"><a href="https://twitter.com/intent/tweet?url=https://gwagner57.github.io/oes/js/Core1/tutorial.html&amp;text=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs-Core1" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-twitter" viewBox="0 0 18 18"><path d="M16.5,4.3c-0.6,0.2-1.1,0.4-1.8,0.5c0.6-0.4,1.1-1,1.4-1.7c-0.6,0.4-1.3,0.6-2,0.8c-0.6-0.6-1.4-1-2.2-1 c-1.7,0-3.1,1.4-3.1,3.1c0,0.2,0,0.5,0.1,0.7C6.3,6.5,4.1,5.3,2.5,3.4C2.3,3.9,2.1,4.4,2.1,5c0,1.1,0.5,2,1.4,2.6 c-0.5,0-1-0.2-1.4-0.4c0,0,0,0,0,0c0,1.5,1.1,2.8,2.5,3.1c-0.3,0.1-0.5,0.1-0.8,0.1c-0.2,0-0.4,0-0.6-0.1c0.4,1.2,1.5,2.1,2.9,2.2 c-1.1,0.8-2.4,1.3-3.8,1.3c-0.2,0-0.5,0-0.7,0c1.4,0.9,3,1.4,4.7,1.4c5.7,0,8.8-4.7,8.8-8.9c0-0.1,0-0.3,0-0.4 C15.6,5.5,16.1,4.9,16.5,4.3"></path></symbol> <use xlink:href="#social-twitter" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share linkedin" title="Share on LinkedIn"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://gwagner57.github.io/oes/js/Core1/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-linkedin" viewBox="0 0 18 18"><path d="M15.4,1.5H2.6C2,1.5,1.5,2,1.5,2.6v12.8c0,0.6,0.5,1.1,1.1,1.1h12.8c0.6,0,1.1-0.5,1.1-1.1V2.6C16.5,2,16,1.5,15.4,1.5z M3.8,7.1H6v7.2H3.8V7.1z M4.9,6.1c-0.7,0-1.3-0.6-1.3-1.3c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3C6.2,5.6,5.6,6.1,4.9,6.1z M14.5,14.3h-2.3v-3.5c0-0.8,0-1.9-1.2-1.9c-1.2,0-1.4,0.9-1.4,1.8v3.5H7.4V7.1h2.2v1h0c0.3-0.6,1-1.2,2.1-1.2 c2.3,0,2.7,1.5,2.7,3.4V14.3z"></path></symbol> <use xlink:href="#social-linkedin" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share email" title="Share with Email"><a aria-label="Share with Email" href="mailto:?subject=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs-Core1&amp;body=This%20article%20shows%20how%20to%20create%20and%20run%20a%20simulation%20model%20with%20the%20JavaScript-based%20simulation%20framework%20OESjs-Core1%20available%20on%20Sim4edu.com.%20OESjs-Core1%20implements%20the%20Object%20Event%20Simulation%20paradigm%2C%20representing%20a%20general%20Discrete%20Event%20Simulation%20approach%20based%20on%20object-oriented%20modeling%20and%20event%20scheduling.%0A%0Ahttps://gwagner57.github.io/oes/js/Core1/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-mail" viewBox="0 0 18 18"><path d="M9,8.2L3,4.5h12L9,8.2z M15,13.5H3V6l6,3.8L15,6V13.5z M15,3H3C2.2,3,1.5,3.7,1.5,4.5l0,9C1.5,14.3,2.2,15,3,15 h12c0.8,0,1.5-0.7,1.5-1.5v-9C16.5,3.7,15.8,3,15,3z"></path></symbol> <use xlink:href="#social-mail" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li></ul> </div><div id="tutorial-content-1__subtitle">How to create and run simulations with the JavaScript-based simulation library <a href="https://gwagner57.github.io/oes/">OESjs-Core1</a> available from the <a href="https://github.com/gwagner57/oes">OES GitHub repo</a></div> <div id="tutorial-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Copyright Â© 2020 Gerd Wagner (<a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC</a>)</p><p>Published 2020-08-26</p><h2>Abstract</h2><p>This tutorial article explains how to use the OESjs-Core1 simulation library, which implements an architecture for Object Event Simulation (OES), extending the OESjs Core 0 simulator by adding fixed-increment time progression, a seedable random number generator, a set of sampling functions from various probability distributions (uniform, triangular, normal, exponential, etc.), multiple scenarios per model, multiple experiment types per model, model parameters, parameter variation experiments, as well as persistent storage and export of experiment results.</p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index"><span class="role-label"><span class="role-number">1</span>. </span>Introduction to Object Event Modeling</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#CM"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#DesM"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-2"><span class="role-label"><span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs-Core1</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimTime"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimModels"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimScenarios"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimStatistics"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimExperiments"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimLog"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-appendix"><a class="role-appendix-ref" href="#architecture"><span class="role-label"><span class="role-number">A</span>. </span>Simulator Architecture</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label"><span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__lof__2"><span class="role-label"><span class="role-number">1-2</span>. </span>A process design model in the form of an Event Graph, where the state variable <i>Q</i> stands for <i>queueLength</i></a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label"><span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__lof__4"><span class="role-label"><span class="role-number">1-4</span>. </span>A process design model in the form of a DPMN Process Diagram</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-table-ref" href="#SimModels__lot__1"><span class="role-label"><span class="role-number">2-1</span>. </span>Simulation Log</a></li><li class="role-booklist-entry"><a class="role-table-ref" href="#SimStatistics__lot__2"><span class="role-label"><span class="role-number">2-2</span>. </span>Statistics</a></li></ul></section></div><section class="role-chapter" id="index"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling</h1><p>Simulation is used widely today: in many scientific disciplines for investigating specific research questions, in engineering for testing the performance of designs, in education for providing interactive learning experiences, and in entertainment for making games.</p><p>Both static systems/structures and dynamic systems can be modeled and simulated. Modeling and simulation (M&amp;S) of <em>static structures</em>, such as the surface textures of materials, is only an issue in physics and computer graphics, while M&amp;S of dynamic systems is an issue in all scientific and engineering disciplines, including management science, economics and other social sciences.</p><p>A <em>dynamic system</em><a class="role-index-anchor" id="index__I__1"></a> may be subject to discrete or continuous state changes. For simulating a dynamic system one has to model</p><ol><li>the types of objects it is composed of,</li><li>the types of events that cause discrete state changes of objects,</li><li>the discrete state changes of objects caused by the occurrence of an event of some type,</li><li>the follow-up events caused by the occurrence of an event of some type,</li><li>the continuous state changes of objects (described with the help of differential equations).</li></ol><p>A (purely) continuous dynamic system<a class="role-index-anchor" id="index__I__2"></a> does not include events and their causal effects (list items 2-4), but only objects that are subject to continuous state changes (list items 1 and 5). A (purely) discrete dynamic system<a class="role-index-anchor" id="index__I__3"></a> does not include any continuous state changes of objects (list item 5). Many real-world systems include both discrete and continuous state changes, in which case they may be called <em>hybrid</em> dynamic systems.</p><p>In this tutorial, we are only concerned with discrete state changes. Consequently, we only consider purely discrete dynamic systems, also called <em>discrete event systems</em><a class="role-index-anchor" id="index__I__4"></a>, which consist of:</p><ul><li><b>objects</b> (of various types) whose states may be changed by</li><li><b>events</b> (of various types) occurring in a sequence of time points, causing state changes of affected objects and follow-up events.</li></ul><p>This means that for modeling such a system, we have to</p><ol><li>describe its <b>object types</b> and <b>event types</b> (in an <em>information model</em>);</li><li>specify, for any event type, the <b>state changes</b> of objects and the <b>follow-up events</b> caused by the occurrence of an event of that type (in a <em>process model</em>).</li></ol><section class="role-section1" id="CM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</h2><figure class="right"><img alt="" src="tutorial_files/service-desk.svg" width="200" /></figure><p>Let's look at an example. We model a system of one or more service desks, each of them having its own queue, as a discrete event system:</p><ul><li>Customers arrive at a service desk at random times.</li><li>If there is no other customer in front of them, and the service desk is available, they are served immediately, otherwise they have to queue up in a waiting line.</li><li>The duration of services varies, depending on the individual case.</li><li>When a service is completed, the customer departs and the next customer is served, if there is still any customer in the queue.</li></ul><p>The potentially relevant <b>object types</b> of the system under investigation are:</p><ul><li>customers,</li><li>service desks,</li><li>waiting lines,</li><li>service clerks, if the service is performed by (one or more) clerks.</li></ul><p>The potentially relevant <b>event types</b> are:</p><ul><li>customer arrivals,</li><li>service starts,</li><li>service terminations,</li><li>customer departures.</li></ul></section><section class="role-section1" id="DesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</h2><p>When making a simulation design based on the conceptual model of the system under investigation, wee need to abstract away from many items of the conceptual model for obtaining a sufficiently simple design. The right degree of abstraction depends on the purpose of the model. But abstracting away from too many things may make a model too unnatural and not sufficiently generic, implying that it cannot be easily extended to model additional features (such as more than one service desk).</p><p>In our example, the purpose of the simulation model is to compute the <em>maximum queue length</em> and possibly also the <em>service utilization</em>. So, we may abstract away from the following object types:</p><ul><li><em>customers</em>: we don't need any information about individual customers.</li><li><em>waiting lines</em>: we don't need to know who is next, it's sufficient to know the length of the queue.</li><li><em>service clerks</em>: we don't need any information about the service clerk(s).</li></ul><p>Notice that, for simplicity, we consider the customer that is currently being served to be part of the queue. In this way, in the simulation program, we can check if the service desk is busy by testing if the length of the queue is greater than 0. In fact, for being able to compute the service utilization and the maximum queue length, the queue length is the only relevant state variable.</p><p>State variables can be modeled in the simple form of <em>global variables</em> or in the form of <em>attributes</em> of suitable object types. Consequently, the simplest model we can make for the given problem, called <em>Service-Desk-0</em>, has only one global variable: <i>queueLength</i>. But, as an alternative, more explicit, model, called <em>Service-Desk-1</em>, we will also model the system state in terms of (one or more) <i>ServiceDesk</i> objects having only one property: <i>queueLength</i>. As opposed to the simpler model defining <i>queueLength</i> as a global variable, this model allows defining simulation scenarios with two or more service desks operating simultaneously.</p><p>We also look for opportunities to simplify our event model by dropping event types that are not needed, e.g., because their events temporally coincide with events of another type. This is the case with <em>service terminations</em> and <i>customer departure</i> events. Consequently, we can drop the event type <em>service terminations</em>.</p><p>There are two situations when a new service can be started: either when the waiting line is empty and a new customer arrives, or when the waiting line is not empty and a service terminates. Therefore, any <em>service start</em> event immediately follows either a <i>customer arrival</i> or a <i>customer departure</i> event, and we may abstract away from <em>service start</em> events and drop the corresponding event type from the design model.</p><p>So we only need to consider <i>customer arrival</i> and <i>customer departure</i> events, modeled with the two event types <i>Arrival</i> and <i>Departure</i>.</p><p>The event type <i>Arrival</i> is an example of a type of <b>exogenous</b> events,<a class="role-index-anchor" id="DesM__I__5"></a> which are not caused by any causal regularity of the system under investigation and, therefore, have to be modeled with a <b>recurrence</b><a class="role-index-anchor" id="DesM__I__6"></a> function that allows to compute the time of the next occurrence of an event of that type. In OES, exogenous event types are a built-in concept such that an OES simulator takes care of creating the next exogenous event whenever an event of that type is processed. This mechanism makes sure that there is a continuous stream of exogenous events throughout a simulation run.</p><p>We also have to model the random variations of two variables: (1) the recurrence of (that is, the time in-between two) customer arrival events and (2) the service duration. In a class model, such random variables<a class="role-index-anchor" id="DesM__I__7"></a> can be defined as special class-level (&quot;static&quot;) operations, with a stereotype Â«rvÂ», in the class to which they belong, as shown in the diagrams below.</p><p>We model the recurrence of customer arrival events as a discrete random variable with a uniform distribution between 1 and 6 minutes, which we express in the class diagram of the information design model by appending the symbolic expression <i>U{1-6}</i> within curly braces to the operation declaration, following the UML syntax for property/method modifiers.</p><p>We model the <i>service time</i> random variable with an empirical distribution of 2 minutes with probability 0.3, 3 minutes with probability 0.5 and 4 minutes with probability 0.2, using the symbolic expression <i>Freq{ 2:0.3, 3:0.5, 4:0.2}</i>.</p><p>Computationally, object types and event types correspond to classes, either of an object-oriented information model, such as a UML class diagram, or of a computer program written in an object-oriented programming language, such as Java or JavaScript.</p><section><h4>1.2.1.Â Service-Desk-0: Modeling <i>queueLength</i> as a global variable</h4><p>As discussed above, the simplest model for the service desk problem with maximum queue length statistics (available in the Sim4edu library as <a href="https://sim4edu.com/sims/14" target="_top">Service-Desk-0</a>) has only one global variable: <i>queueLength</i>, which is a non-negative integer, and a global function for computing the random service time, but no object type.</p><p>An information model for Service-Desk-0 consists of a special class for defining model variables and functions, and two classes for defining the event types <i>Arrival</i> and <i>Departure</i>, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</a>.</p><figure id="DesM__figServiceDesk0"><figcaption><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</figcaption><div><img alt="???" src="tutorial_files/IDM0.svg" width="360" /></div></figure><p>In addition to an information design model for defining the simulation system's state structure, we also need to make a process design model for defining the dynamics of the simulation system. The dynamics of a system consists of events triggering state changes and follow-up events. A process model can be expressed with the help of event rules, which define what happens when an event (of a certain type) occurs, or, more specifically, which state changes and which follow-up events are caused by an event of that type.</p><p>Event rules can be expressed with the help of a process model diagram or in pseudo-code, or in a simulation or programming language. The following <em>Event Graph</em> provides a process design model for the Service-Desk-0 simulation scenario. Circles represent events (or, more precisely, event types) and arrows, which may be annotated with a delay expression, such as +serviceTime(), represent event scheduling relationships. An arrow with a mini-diamond at its source end represents a conditional event scheduling relationship where the condition is expressed in brackets below or above the arrow.</p><figure id="DesM__lof__2"><figcaption><span class="role-label">Figure <span class="role-number">1-2</span>. </span>A process design model in the form of an Event Graph, where the state variable <i>Q</i> stands for <i>queueLength</i></figcaption><div><img alt="???" src="tutorial_files/ServiceDesk0_EG.svg" width="360" /></div></figure><p>Event Graphs have originally been proposed by L. Schruben (<a href="https://dl.acm.org/citation.cfm?id=358460">1983</a>). Their visual syntax has been improved and harmonized with the business process modeling language <em>BPMN</em> in the <em>Discrete Event Process Modeling Notation (DPMN)</em> proposed by Wagner (<a href="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I">2018</a>) and more thoroughly described in the book <a href="https://sim4edu.com/reading/des-engineering/">Discrete Event Simulation Engineering</a>.</p><p>The following table shows the two event rules defined by the above Event Graph, expressed in pseudo-code.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>Arrival @ t</p></td><td><pre>INCREMENT queueLength
IF queueLength = 1 THEN
  sTime := serviceTime()
  SCHEDULE Departure @ (t + sTime)
</pre></td></tr><tr><td><p>Departure @ t</p></td><td><pre>DECREMENT queueLength
IF queueLength &gt; 0 THEN
  sTime := serviceTime()
  SCHEDULE Departure @ (t + sTime)</pre></td></tr></tbody></table></section> <section><h4>1.2.2.Â Service-Desk-1: Modeling <i>queueLength</i> as an attribute</h4><p>In our extended model (<a href="https://sim4edu.com/sims/1" target="_top">Service-Desk-1</a>) we represent the state variable <i>queueLength</i> as an attribute of an object type <i>ServiceDesk</i>. This results in a model with three classes, the object class <i>ServiceDesk</i> with an attribute <i>queueLength</i>, and the event classes <i>Arrival</i> and <i>Departure</i>, both with a reference property <i>serviceDesk</i> for referencing the service desk at which an event occurs. When we also want to compute the service utilization statistics, we need to add an attribute <i>serviceTime</i> to the <i>Departure</i> class for being able to update the service utilization statistics when a customer departs.</p><p>Both event types, <i>Arrival</i> and <i>Departure</i>, now have a many-to-one association with the object type <i>ServiceDesk</i>. This expresses the fact that any such event occurs at a particular service desk, which participates in the event. This association is implemented in the form of a reference property <i>serviceDesk</i> in each of the two event types, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label">Figure <span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</a>.</p><figure id="DesM__figServiceDesk1"><figcaption><span class="role-label">Figure <span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</figcaption><div><img alt="???" src="tutorial_files/IDM1.svg" width="400" /></div></figure><p>In addition to an information model, we need to make a process model, which captures the dynamics of the service desk system consisting of arrival and departure events triggering state changes and follow-up events. The following <em>DPMN Process Diagram</em> provides a process design model for the Service-Desk-1 simulation scenario. As in Event Graphs, circles represent event types and arrows represent event scheduling relationships. DPMN extends Event Graphs by adding object rectangles, attached to event circles, representing state change patterns for objects that are affected by events of that type.</p><figure id="DesM__lof__4"><figcaption><span class="role-label">Figure <span class="role-number">1-4</span>. </span>A process design model in the form of a DPMN Process Diagram</figcaption><div><img alt="???" src="tutorial_files/ServiceDesk-1_PDM.svg" width="600" /></div></figure><p>The following table shows the two event rules defined by the DPMN diagram, which now account for the fact that both types of events occur at a particular service desk that is referenced by the event expression parameter <i>sd</i>.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>Arrival( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>INCREMENT sd.queueLength
IF sd.queueLength = 1 THEN
  sTime := ServiceDesk.serviceTime()
  SCHEDULE Departure( sTime, sd) @(t + sTime)
</pre></td></tr><tr><td><p>Departure( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>DECREMENT sd.queueLength
IF sd.queueLength &gt; 0 THEN
  sTime := ServiceDesk.serviceTime()
  SCHEDULE Departure( sTime, sd) @(t + sTime)</pre></td></tr></tbody></table></section></section></section><section class="role-chapter" id="index-2"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs-Core1</h1><p>The JavaScript-based simulator <i>OESjs-Core1</i> implements the <i>Object Event Simulation (<a href="https://sim4edu.com/OES" target="_top">OES</a>)</i> paradigm, representing a general <i>Discrete Event Simulation</i> approach based on <i>object-oriented</i> modeling and <i>event scheduling</i>. </p><p>The code of an OESjs-Core1 simulation consists of (1) the OESjs-Core1 library files in the folder <kbd>OESjs-Core1</kbd>, (2) general library files in the <kbd>lib</kbd> folder and (3) the following files to be created by the simulation developer:</p><ol><li>For each object type <i>ObjT</i>, a JS code file <kbd>ObjT.js</kbd>.</li><li>For each event type <i>EvtT</i>, a JS code file <kbd>EvtT.js</kbd>.</li><li>A <kbd>simulation.js</kbd> file defining further parts of the simulation, such as statistics variables and the initial state.</li></ol><p>OESjs-Core1 supports three forms of simulations:</p><ol><li><p>Standalone scenario simulations, which are good for getting a quick impression of a simulation model, e.g., by checking some simple statistics.</p></li><li><p>Simple simulation experiments, which are defined as a set of replicated simulation scenario runs, providing summary statistics like mean, standard deviation, minimum/maximum and confidence intervals for each statistics variable defined in the underlying model.</p></li><li><p>Parameter variation experiments, for which a set of experiment parameters with value sets are defined such that each experiment parameter corresponds to a model parameter. When an experiment is run, each experiment parameter value combination defines an experiment scenario, which is run repeatedly, according to the specified number or replications for collecting statistics.</p></li></ol><p>OESjs-Core1 allows to define two or more simulation scenarios for a given model. While an experiment type is defined for a given model, an experiment of that type is run on top of a specific scenario.</p><p>Using a simulation library like OESjs Core1 means that only the model-specific logic has to be coded (in the form of object types, event types, event routines and other functions for model-specific computations), but not the general simulator operations (e.g., time progression and statistics) and the environment handling (e.g., user interfaces for statistics output).</p><p>The following sections present the basic concepts of the OESjs<i> </i>Core1 simulation library, and show how to implement the service desk models described in <a class="role-chapter-ref" href="#index"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling</a>.</p><blockquote class="role-attention"><p>While you can directly run an OESjs Core1 simulation model from a remote website (e.g., from the OES GitHub website), you can only run it from your local file system after changing your browser's default configuration. </p><p>For FireFox, you have to set the configuration property <code>privacy.file_unique_origin</code> to <i>false</i> by entering <code>about:config</code> in the browser's web address bar.</p></blockquote><section class="role-section1" id="SimTime"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</h2><p>A simulation model has an underlying <b><i>time model</i></b>, which can be either <i>discrete time</i>, when setting</p><pre>sim.model.time = &quot;discrete&quot;;</pre><p>or <i>continuous time</i>, when setting</p><pre>sim.model.time = &quot;continuous&quot;;</pre><p>Choosing a discrete time model means that time is measured in steps (with equal durations), and all temporal random variables used in the model need to be discrete (i.e., based on discrete probability distributions). Choosing a continuous time model means that one has to define a <i>simulation time granularity</i>, as explained in the next sub-section.</p><p>In both cases, the underlying simulation <b><i>time unit</i></b> can be either left unspecified (e.g., in the case of an abstract time model), or it can be set to one of the time units &quot;ms&quot;, &quot;s&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;, &quot;month&quot; or &quot;year&quot;, as in</p><pre>sim.model.timeUnit = &quot;hour&quot;;</pre><p>Typical examples of time models are:</p><ol><li><p>An abstract discrete model of time where time runs in steps without any concrete meaning: </p><pre>sim.model.time = &quot;discrete&quot;;</pre></li><li><p>A concrete discrete model of time in number of days: </p><pre>sim.model.time = &quot;discrete&quot;;
sim.model.timeUnit = &quot;day&quot;;</pre></li><li><p>A concrete continuous model of time in number of seconds: </p><pre>sim.model.time = &quot;continuous&quot;;
sim.model.timeUnit = &quot;s&quot;;</pre></li></ol><section><h4>2.1.1. Time Granularity</h4><p>A model's <em>time granularity</em> is the time delay until the next moment, such that the model does not allow considering an earlier next moment. This is captured by the simulation parameter <i>nextMomentDeltaT</i> used by the simulator for scheduling immediate events with a minimal delay. When a simulation model is based on discrete time, <i>nextMomentDeltaT</i> is set to 1, referring to the next time point. When a simulation model is based on continuous time, <i>nextMomentDeltaT</i> is set to the default value 0.001, unless the model parameter <code>sim.model.nextMomentDeltaT</code> is explicitly assigned in the <kbd>simulation.js</kbd> file.</p></section><section><h4>2.1.2. Time Progression</h4><p>An important issue in simulation is the question how the simulation time is advanced by the simulator. The OES paradigm supports <strong>next-event</strong> time progression and <strong>fixed-increment</strong> time progression, as well as their combination.</p><p>An OESjs-Core1 model with fixed-increment time progression has to define a suitable periodic time event type, like <code>EachSecond</code> or <code>EachDay</code> in the form of an exogenous event type with a recurrence function returning the value 1. Such a model can be used for</p><ol><li>modeling continuous state changes (e.g., objects moving in a continuous space), or</li><li>making a discrete model that abstracts away from explicit events and uses only implicit periodic time events (&quot;ticks&quot;), which is a popular approach in social science simulation.</li></ol><p>Examples of discrete event simulation models with fixed-increment time progression and no explicit events are the <a href="https://sim4edu.com/sims/6">Schelling Segregation Model</a> and the <a href="https://sim4edu.com/sims/25/index.html">Susceptible-Infected-Recovered (SIR) Disease Model</a>.</p></section></section><section class="role-section1" id="SimModels"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</h2><section><h4>2.2.1. Model Variables and Functions</h4><p>In the simple model of a service desk discussed in the previous section, we define one (global) model variable, <i>queueLength</i>, one model function, <i>serviceTime</i>(), and two event types, as shown in the following class diagram: </p><figure><img alt="???" src="tutorial_files/IDM0.svg" width="400" /></figure><p>Notice that this model does not define any object type, which implies that the system state is not composed of the states of objects, but of the states of model variables, here it consists of the state of the model variable <i>queueLength</i>. The discrete random variable for modeling the random variation of service durations is implemented as a model function <code>serviceTime</code> shown in the <i>Global Variables and Functions</i> class. It samples integers between 2 and 4 from the empirical probability distribution <i>Frequency{ 2:0.3, 3:0.5, 4:0.2}</i>. The model can be coded with OESjs-Core1 in the following way:</p><pre>// (global) model variable
sim.model.v.<strong>queueLength</strong> = 0;
// (global) model function
sim.model.f.<strong>serviceTime</strong> = function () {
  var r = math.getUniformRandomInteger( 0, 99);
  if ( r &lt; 30) return 2;         // probability 0.30
  else if ( r &lt; 80) return 3;    // probability 0.50
  else return 4;                 // probability 0.20
};</pre><p>You can <a href="https://gwagner57.github.io/oes/js/Core0/Service-Desk-0/index.html" target="_top">run this Service-Desk-0 model</a> from the project's GitHub website. An example of a run of this model is shown in the following simulation log: </p><table border="1" id="SimModels__lot__1"><caption><span class="role-label">Table <span class="role-number">2-1</span>. </span>Simulation Log</caption><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody id="SimModels__simLog"><tr><td>0</td><td>0</td><td>queueLength: 0</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>queueLength: 1</td><td>CustomerDeparture@4, CustomerArrival@4</td></tr><tr><td>2</td><td>4</td><td>queueLength: 1</td><td>CustomerDeparture@6, CustomerArrival@7</td></tr><tr><td>3</td><td>6</td><td>queueLength: 0</td><td>CustomerArrival@7</td></tr><tr><td>4</td><td>7</td><td>queueLength: 1</td><td>CustomerDeparture@11, CustomerArrival@13</td></tr><tr><td>5</td><td>11</td><td>queueLength: 0</td><td>CustomerArrival@13</td></tr><tr><td>6</td><td>13</td><td>queueLength: 1</td><td>CustomerDeparture@15, CustomerArrival@19</td></tr><tr><td>7</td><td>15</td><td>queueLength: 0</td><td>CustomerArrival@19</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>49</td><td>114</td><td>queueLength: 0</td><td>CustomerArrival@117</td></tr><tr><td>50</td><td>117</td><td>queueLength: 1</td><td>CustomerArrival@118, CustomerDeparture@119</td></tr><tr><td>51</td><td>118</td><td>queueLength: 2</td><td>CustomerDeparture@119, CustomerArrival@119</td></tr><tr><td>52</td><td>119</td><td>queueLength: 2</td><td>CustomerArrival@121, CustomerDeparture@123</td></tr><tr><td>53</td><td>121</td><td>queueLength: 3</td><td>CustomerDeparture@123, CustomerArrival@124</td></tr><tr><td>54</td><td>123</td><td>queueLength: 2</td><td>CustomerArrival@124, CustomerDeparture@126</td></tr><tr><td>55</td><td>124</td><td>queueLength: 3</td><td>CustomerArrival@125, CustomerDeparture@126</td></tr><tr><td>56</td><td>125</td><td>queueLength: 4</td><td>CustomerDeparture@126, CustomerArrival@128</td></tr><tr><td>57</td><td>126</td><td>queueLength: 3</td><td>CustomerArrival@128, CustomerDeparture@128</td></tr><tr><td>58</td><td>128</td><td>queueLength: 3</td><td>CustomerArrival@129, CustomerDeparture@131</td></tr><tr><td>59</td><td>129</td><td>queueLength: 4</td><td>CustomerDeparture@131, CustomerArrival@133</td></tr><tr><td>60</td><td>131</td><td>queueLength: 3</td><td>CustomerArrival@133, CustomerDeparture@135</td></tr><tr><td>61</td><td>133</td><td>queueLength: 4</td><td>CustomerDeparture@135, CustomerArrival@137</td></tr><tr><td>62</td><td>135</td><td>queueLength: 3</td><td>CustomerArrival@137, CustomerDeparture@137</td></tr><tr><td>63</td><td>137</td><td>queueLength: 3</td><td>CustomerArrival@139, CustomerDeparture@141</td></tr><tr><td>64</td><td>139</td><td>queueLength: 4</td><td>CustomerDeparture@141, CustomerArrival@142</td></tr><tr><td>65</td><td>141</td><td>queueLength: 3</td><td>CustomerArrival@142, CustomerDeparture@144</td></tr><tr><td>66</td><td>142</td><td>queueLength: 4</td><td>CustomerDeparture@144, CustomerArrival@147</td></tr><tr><td>67</td><td>144</td><td>queueLength: 3</td><td>CustomerArrival@147, CustomerDeparture@148</td></tr><tr><td>68</td><td>147</td><td>queueLength: 4</td><td>CustomerDeparture@148, CustomerArrival@148</td></tr><tr><td>69</td><td>148</td><td>queueLength: 4</td><td>CustomerArrival@149, CustomerDeparture@151</td></tr><tr><td>70</td><td>149</td><td>queueLength: 5</td><td>CustomerDeparture@151, CustomerArrival@151</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table></section><section><h4>2.2.2. Object Types</h4><p>Object types are defined in the form of classes. Consider the object type <i>ServiceDesk</i> defined in the following <i>Service-Desk-1</i> model: </p><figure><img alt="???" src="tutorial_files/IDM1.svg" width="400" /></figure><p>While <code>queueLength</code> was defined as a global variable in the <i>Service-Desk-0</i> model, it is now defined as an attribute of the object type <i>ServiceDesk</i>:</p><pre>class <b>ServiceDesk</b> extends oBJECT {
  constructor({ id, name, queueLength}) {
    super( id, name);
    this.<b>queueLength</b> = queueLength;
  }
  static <b>serviceTime</b>() {
    var r = math.getUniformRandomInteger( 0, 99);
    if ( r &lt; 30) return 2;         // probability 0.3
    else if ( r &lt; 80) return 3;    // probability 0.5
    else return 4;                 // probability 0.2
  }
}
ServiceDesk.<b>labels</b> = {&quot;queueLength&quot;:&quot;qLen&quot;};  // for the log</pre><p>Notice that, in OESjs, object types are defined as subtypes of the pre-defined class <code>oBJECT</code>, from which they inherit an integer-valued <code>id</code> attribute and an optional <code>name</code> attribute. When a property has a <code>label</code> (defined by the class-level (map-valued) property <code>labels</code>), it is shown in the simulation log.</p><p>You can <a href="https://gwagner57.github.io/oes/js/Core0/Service-Desk-1/index.html" target="_top">run this simulation model</a> from the project's GitHub website.</p></section><section><h4>2.2.3. Event Types</h4><p>In OES, there is a distinction between two kinds of events:</p><ol><li>events that are <em>caused</em> by other event occurrences during a simulation run;</li><li><em>exogenous</em> events that seem to happen spontaneously, but may be caused by factors, which are external to the simulation model.</li></ol><p>Here is an example of an exogenous event type definition in OESjs-Core1:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.<b>serviceDesk</b> = serviceDesk;
  }
  <b>onEvent</b>() {
    ...
  }
  ...
}</pre><p>The definition of the <i>CustomerArrival</i> event type includes a reference property <i>serviceDesk</i>, which is used for referencing the service desk object at which a customer arrival event occurs. In OESjs, event types are defined as subtypes of the pre-defined class <code>eVENT</code>, from which they inherit an attribute <code>occTime</code>, which holds the occurrence time<a class="role-index-anchor" id="SimModels__I__8"></a> of an event. As opposed to objects, events do normally not have an ID, nor a name. </p><p>Each event type needs to define an <code>onEvent</code> method that implements the event rule for events of the defined type. Event rules are discussed below. </p><p>Exogenous events occur periodically. They are therefore defined with a <em>recurrence</em> function,<a class="role-index-anchor" id="SimModels__I__9"></a> which provides the time in-between two events (often in the form of a random variable). The recurrence function is defined as a class-level (&quot;static&quot;) method:</p><pre>class CustomerArrival extends eVENT {
  ...
  static <b>recurrence</b>() {
    return math.getUniformRandomInteger( 1, 6);
  }
}</pre><p>Notice that the <i>recurrence</i> function of <i>CustomerArrival</i> is coded with the library method <code class="code">math.getUniformRandomInteger</code>, which allows sampling from discrete uniform probability distribution functions. </p><p>In the case of an exogenous event type definition, a <i>createNextEvent</i> method has to be defined for assigning event properties and returning the next event of that type, which is scheduled by invoking the <i>recurrence</i> function for setting its <i>ocurrenceTime</i> and by copying all participant references (such as the <i>serviceDesk</i> reference). </p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  <b>createNextEvent</b>() {
    return new CustomerArrival({
      occTime: this.occTime + CustomerArrival.<b>recurrence</b>(),
      serviceDesk: this.serviceDesk
    });
  }
  static <b>recurrence</b>() {...}
}</pre><p>When an OE simulator processes an exogenous event <i>e</i> of type <i>E</i>, it automatically schedules the next event of type <i>E</i> by invoking the <i>createNextEvent</i> method on <i>e</i>, if it is defined, or, otherwise by duplicating <i>e</i> and resetting its occurrence time by invoking <i>E</i>.recurrence().</p><p>For an exogenous event type, it is an option to define a maximum number of event occurrences by setting the static attribute <code>maxNmrOfEvents</code>, as in the following example:</p><pre>CustomerArrival.<b>maxNmrOfEvents</b> = 3;</pre><p>The second event type of the <i>Service-Desk-1</i> model, <i>Departure</i>, is an example of a type of <i>caused</i> events:</p><pre>class <b>CustomerDeparture</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.serviceDesk = serviceDesk;
  }
  onEvent() {
    ...
  }
}</pre><p>A caused event type does neither define a <i>recurrence</i> function nor a <i>createNextEvent</i> method.</p></section><section><h4>2.2.4. Event Rules</h4><p>An event rule<a class="role-index-anchor" id="SimModels__I__a"></a> for an event type defines what happens when an event of that type occurs, by specifying the caused state changes and follow-up events. In OESjs, event rules are coded as <code>onEvent</code> methods of the class that implements the event type. These methods return a set of events (more precisely, a set of JS objects representing events).</p><p>Notice that in the DES literature, event rule methods are called <i>event routines</i><a class="role-index-anchor" id="SimModels__I__b"></a>.</p><p>For instance, in the <code>CustomerArrival</code> class, the following event rule method is defined:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // increment queue length due to newly arrived customer
    this.serviceDesk.<b>queueLength</b>++;
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    // if the service desk is not busy
    if (this.serviceDesk.queueLength === 1) {
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre><p>The context of this event rule method is the event that triggers the rule, that is, the variable <code>this</code> references a JS object that represents the triggering event. Thus, the expression <code>this.serviceDesk</code> refers to the service desk object associated with the current customer arrival event, and the statement <code>this.serviceDesk.queueLength++</code> increments the <i>queueLength</i> attribute of this service desk object (as an immediate state change).</p><p>The following event rule method is defined in the <code>CustomerDeparture</code> class. </p><pre>class <b>CustomerDeparture</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // decrement queue length due to departure
    this.serviceDesk.<b>queueLength</b>--;
    // update statistics
    sim.stat.<b>departedCustomers</b>++;
    // if there are still customers waiting
    if (this.serviceDesk.queueLength &gt; 0) {
      // start next service and schedule its end/departure
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre></section><section><h4>2.2.5. Event Priorities</h4><p>An OES model may imply the possibility of several events occurring at the same time. Consequently, a simulator (like OESjs) must be able to process simultaneous events.<a class="role-index-anchor" id="SimModels__I__c"></a> In particular, simulation models based on discrete time may create simulation states where two or more events occur at the same time, but the model's logic requires them to be processed in a certain order. Defining priorities for events of a certain type helps to control the processing order of simultaneous events.</p><p>Consider an example model based on discrete time with three exogenous event types <i>StartOfMonth</i>, <i>EachDay</i> and <i>EndOfMonth</i>, where the recurrence of StartOfMonth and EndOfMonth is 21, and the recurrence of EachDay is 1. In this example we want to control that on simulation time 1 + <i>i</i> * 21 both a StartOfMonth and an EachDay event occur simultaneously, but StartOfMonth should be processed before EachDay, and on simulation time 21 + <i>i</i> * 21 both an EndOfMonth and an EachDay event occur simultaneously, but EndOfMonth should be processed after EachDay. This can be achieved by defining a high priority, say 2, to StartOfMonth, a middle priority, say 1, to StartOfMonth, and a low priority, say 0, to EndOfMonth. </p><p>Event priorities are defined as class-level properties of event classes in the event type definition file. Thus, we would define in <kbd>StartOfMonth.js</kbd>:</p><pre>StartOfMonth.priority = 2;</pre><p>and in <kbd>EachDay.js</kbd>:</p><pre>EachDay.priority = 1;</pre><p>and finally in <kbd>EndOfMonth.js</kbd>:</p><pre>EndOfMonth.priority = 0;</pre></section><section><h4>2.2.6. Library Methods for Sampling Probability Distribution Functions</h4><p>Random variables<a class="role-index-anchor" id="SimModels__I__d"></a> are implemented as methods that sample specific <em>probability distribution functions (PDFs)</em>.<a class="role-index-anchor" id="SimModels__I__e"></a> Simulation frameworks typically provide a library of predefined parametrized PDF sampling methods, which can be used with one or several (possibly seeded) streams of <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_top">pseudo-random numbers</a>.</p><p>The OESjs simulator provides the following predefined parametrized PDF sampling methods:</p><table border="1"><thead><tr><td style="text-align:center;"><b>Probability Distribution Function</b></td><td style="text-align:center;"><b>OESjs Library Method</b></td><td style="text-align:center;"><b>Example</b></td></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_top">Uniform</a></td><td><code>uniform</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>rand.uniform( 0.5, 1.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution" target="_top">Discrete Uniform</a></td><td><code>uniformInt</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>rand.uniformInt( 1, 6)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Triangular</a></td><td><code>triangular</code>( <i>lowerBound</i>, <i>upperBound</i>, <i>mode</i>)</td><td><code>rand.triangular( 0.5, 1.5, 1.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Triangular_distribution" target="_top">Frequency</a></td><td><code>frequency</code>( <i>frequencyMap</i>)</td><td><code>rand.frequency({&quot;2&quot;:0.4, &quot;3&quot;:0.6})</code></td></tr><tr><td><a href="http://en.wikipedia.org/wiki/Exponential_distribution" target="_top">Exponential</a></td><td><code>exponential</code>( <i>eventRate</i>)</td><td><code>rand.exponential( 0.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Gamma_distribution" target="_top">Gamma</a></td><td><code>gamma</code>( <i>shape</i>, <i>scale</i>)</td><td><code>rand.gamma( 1.0, 2.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Normal_distribution" target="_top">Normal</a></td><td><code>normal</code>( <i>mean</i>, <i>stdDev</i>)</td><td><code>rand.normal( 1.5, 0.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Pareto_distribution" target="_top">Pareto</a></td><td><code>pareto</code>( <i>shape</i>)</td><td><code>rand.pareto( 2.0)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Weibull_distribution" target="_top">Weibull</a></td><td><code>weibull</code>( <i>scale</i>, <i>shape</i>)</td><td><code>rand.weibull( 1, 0.5)</code></td></tr></tbody></table><p>The OESjs library <kbd>rand.js</kbd> supports both unseeded and seeded random number streams.<a class="role-index-anchor" id="SimModels__I__f"></a> By default, its PDF sampling methods are based on an unseeded stream, using Marsagliaâs high-performance random number generator <a href="https://en.wikipedia.org/wiki/Xorshift" target="_top"><em>xorshift</em></a> that is built into the <code>Math.random</code> function of modern JavaScript engines.</p><p>A seeded random number stream, based on David Bau's seedable random number generator <a href="https://github.com/davidbau/seedrandom">seedrandom</a>, can be obtained by setting the scenario parameter <code>sim.scenario.randomSeed</code> to a positive integer value.</p><p>Additional streams can be defined and used in the following way:</p><pre>var stream1 = new Random( 1234);
var stream2 = new Random( 6789);
var service1Duration = stream1.exponential( 0.5);
var service2Duration = stream2.exponential( 1.5);</pre><blockquote class="role-warning"><p>Avoid using JavaScript's built-in <code>Math.random</code> in simulation code. Always use <code>rand.uniform</code>, or one of the other sampling functions from the <kbd>rand.js</kbd> library described above, for generating random numbers.</p><p>Otherwise, using a random seed does not guarantee reproducible simulation runs!</p></blockquote></section></section><section class="role-section1" id="SimScenarios"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</h2><p>For obtaining a complete executable simulation scenario, a simulation model has to be complemented with <em>simulation parameter settings</em> and an <em>initial system state</em>.</p><p>In general, we may have more than one simulation scenario for a simulation model. For instance, the same model could be used in two different scenarios with different initial states. </p><p>An OESjs <em>simulation scenario</em> consists of</p><ol><li>a simulation model;</li><li>simulation parameter settings, such as setting a value for <code>durationInSimTime</code> and <code>randomSeed</code>; and</li><li>an initial state definition.</li></ol><p>An empty template for the <kbd>simulation.js</kbd> file has the following structure:</p><pre>// ***** Simulation Model *******************
sim.model.time = &quot;...&quot;;  // discrete or continuous
sim.model.timeIncrement = ...;   // optional
sim.model.timeUnit = &quot;...&quot;;  // optional (ms|s|min|hour|day|week|month|year)
sim.model.v.aModelVariable = ...;  // (developer-defined) model variables
sim.model.f.aModelFunction = ...;  // (developer-defined) model functions
<b>sim.model.p.aModelParameter = ...;  // (developer-defined) model parameters</b>
sim.model.objectTypes = [...];  // (developer-defined) object types
sim.model.eventTypes = [...];  // (developer-defined) event types
// ***** Simulation Parameters **************
sim.scenario.durationInSimTime = ...;
sim.scenario.randomSeed = ...;    // optional
// ***** Initial State **********************
sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // Create initial objects
  ...
  // Schedule initial events
  ...
};
// ***** Ex-Post Statistics *****************
sim.model.statistics = {...};</pre><p>We briefly discuss each group of scenario information items in the following sub-sections.</p><section><h4>2.3.1. Model Parameters</h4><p>While model variables are state variables whose values are changed as an effect of an event occurrence, <em>model parameters</em> are not part of the dynamic state of the simulated system, but are rather used for providing values that can only be read during a simulation run. The main purpose of model parameters is to allow <em>parameter variation experiments</em>.</p></section><section><h4>2.3.2. Simulation Scenario Parameters</h4><p>A few simulation parameters are predefined as attributes of the simulation scenario. The most important ones are:</p><ul><li><i>durationInSimTime</i> - this attribute allows defining the duration of a simulation run; which runs forever when this attribute s not set;</li><li><i>randomSeed</i>: Setting this optional parameter to a positive integer allows to obtain a specific fixed random number sequence (generated by a random number generator). This can be used for performing simulation runs with the same (repeated) random number sequence, e.g., for testing a simulation model by checking if expected results are obtained.</li></ul></section><section id="SimScenarios__sectInitialState"><h4>2.3.3. Initial State</h4><p>Defining an initial state means:</p><ol><li>assigning initial values to global model variables, if there are any;</li><li>defining which objects exist initially, and assigning initial values to their properties;</li><li>defining which events are scheduled initially.</li></ol><p>A <code>setupInitialState</code> procedure takes care of these initial state definitions. A global model variable is initialized in the following way: </p><pre>sim.scenario.setupInitialState = function () {
  // <b>Initialize model variables</b>
  <b>sim.model.v.queueLength</b> = 0;
  // Create initial objects
  ...
  // Schedule initial events
  ...
};</pre><p>An initial state object is created by instantiating an object type of the simulation model with suitable initial property values, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // <b>Create initial objects</b>
  let <b>serviceDesk1</b> = new ServiceDesk({id: 1, queueLength: 0});
  // Schedule initial events
  ...
};</pre><p>Notice that object IDs are positive integers, but when used as keys in the map <code>sim.objects</code>, they are converted to strings.</p><p>Instead of assigning a <strong>fixed value</strong> to a property like <code>queueLength</code> for defining an object's initial state, as in <code>queueLength: 0</code>, we can also assign it a <strong>fixed expression</strong>, as in <code>queueLength: Math.round(12/30)</code>.</p><p>An <strong>initial event</strong> is scheduled by adding it to the <em>Future Events List (FEL)</em>, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // Create initial objects
  let desk1 = new ServiceDesk({id: 1, queueLength: 0});
  // <b>Schedule initial events</b>
  sim.<b>FEL.add</b>( <b>new CustomerArrival</b>({occTime:1, serviceDesk: desk1}));
};</pre><p>Initial objects or events can be parametrized with the help of model parameters.</p></section><section><h4>2.3.4. Defining Alternative Scenarios with Different Initial States</h4><p>For running a model on top of different initial states, one can define a list of scenarios, each with its own <code>setupInitialState</code> procedure: </p><pre>sim.<b>scenarios[1]</b> = {
  scenarioNo: 1,
  title: &quot;Scenario with two service desks&quot;,
  setupInitialState: function () {
    // Create initial objects
    var sD1 = new ServiceDesk({id: 1, queueLength: 0}),
        sD2 = new ServiceDesk({id: 2, queueLength: 0});
    // Schedule initial events
    sim.FEL.add( new CustomerArrival({occTime: 1, serviceDesk: sD1}));
    sim.FEL.add( new CustomerArrival({occTime: 2, serviceDesk: sD2}));
  }
};
sim.<b>scenarios[2]</b> = {...}</pre><p>Before running a simulation, a specific scenario can be chosen in the user interface.</p><blockquote class="role-warning"><p>Do not set model parameters in the <code>setupInitialState</code> procedure! This would interfere with parameter variation experiments in which the same parameter(s) are used.</p></blockquote></section></section><section class="role-section1" id="SimStatistics"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</h2><p>In scientific and engineering simulation projects the main goal is getting estimates of the values of certain variables or performance indicators with the help of statistical methods. In educational simulations, statistics can be used for observing simulation runs and for learning the dynamics of a simulation model. </p><p>For collecting statistics, suitable <em>statistics variables</em> have to be defined, as in the following example:</p><pre>sim.model.<b>setupStatistics</b> = function () {
  sim.stat.arrivedCustomers = 0;
  sim.stat.departedCustomers = 0;
  sim.stat.maxQueueLength = 0;
};</pre><p>Statistics variables have to be updated in <i>onEvent</i> methods. For instance, the variables <i>arrivedCustomers</i> and <i>maxQueueLength</i> are updated in the onEvent method of the <i>CustomerArrival</i> event class:</p><pre>class CustomerArrival extends eVENT {
  ...
  onEvent() {
    ...
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    ...
  }
}</pre><p>In certain cases, a statistics variable can only be computed at the end of a simulation run. For this purpose, there is the option to define a <i>computeFinalStatistics</i> procedure:</p><pre>sim.model.<b>computeFinalStatistics</b> = function () {
  // percentage of business days without stock-outs
  sim.stat.serviceLevel = (sim.time - sim.stat.nmrOfStockOuts) / sim.time * 100;
};</pre><p>After running a simulation scenario, the statistics results are shown in a table:</p><table border="1" id="SimStatistics__lot__2"><caption><span class="role-label">Table <span class="role-number">2-2</span>. </span>Statistics</caption><tbody><tr><td>arrivedCustomers</td><td>289</td></tr><tr><td>departedCustomers</td><td>288</td></tr><tr><td>maxQueueLength</td><td>4</td></tr></tbody></table></section><section class="role-section1" id="SimExperiments"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</h2><p>There are different types of simulation experiments. In a <em>simple experiment</em>, a simulation scenario is run repeatedly by defining a number of replications (iterations) for being able to compute average statistics.</p><p>In a <em>parameter variation experiment</em>, several variants of a simulation scenario (called <em>experiment scenarios</em>), are defined by defining value sets for certain <em>model parameters</em> (the <em>experiment parameters</em>), such that a parameter variation experiment run consists of a set of experiment scenario runs, one for each combination of parameter values.</p><p>An experiment type is defined for a given simulation model and an experiment of that type is run on top of a given simulation scenario for that model.</p><p>When running an experiment, the resulting statistics data are stored in a database, which allows looking them up later on or exporting them to data analysis tools (such as Microsoft Excel and RStudio)</p><section><h4>2.6.1. Simple Experiments</h4><p>A simple experiment type is defined with a <code>sim.experimentType</code> record on top of a model by defining (1) the number of <em>replications</em> and (2) possibly a list of <em>seed values</em>, one for each replication. The following code shows an example of a simple experiment type definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experimentType = {
  title: &quot;Simple Experiment with 10 replications, each running for 1000 time units (days)&quot;,
  nmrOfReplications: 10,
  seeds: [123, 234, 345, 456, 567, 678, 789, 890, 901, 1012]
};</pre></td></tr></tbody></table><p>Running this simple experiment means running the underlying scenario 10 times, each time with another random seed, as specified by the list of seeds. The resulting statistics are composed of the statistics for each replication complemented with a summary statistics listing averages, standard deviations, min/max values and confidence intervals.</p><p>When no seeds are defined, the experiment is run with implicit random seeds using JavaScript's built-in random number generator, which implies that experiment runs are not reproducible.</p></section><section><h4>2.6.2. Parameter Variation Experiments</h4><p>A parameter variation experiment is defined with (1) a number of <em>replications</em>, (2) a list of <em>seed values</em> (one for each replication), and (3) one or more experiment parameters. </p><p>An experiment parameter must have the same name as the model parameter to which it refers. It defines a set of values for this model variable, either using a <code>values</code> field or a combination of a <code>startValue</code> and <code>endValue</code> field (and <code>stepSize</code> for a non-default increment value) as in the following example.</p><p>The following code shows an example of a parameter variation experiment definition (on top of the <a href="https://gwagner57.github.io/oes/js/Core1/Inventory-Management/index.html">Inventory-Management</a> simulation model):</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experimentTypes[1] = {
  id: 1,
  title: &quot;Parameter variation experiment for exploring reorderInterval and targetInventory&quot;,
  nmrOfReplications: 10,
  seeds: [123, 234, 345, 456, 567, 678, 789, 890, 901, 1012],
  <b>parameterDefs</b>: [
    {name:&quot;reviewPolicy&quot;, values:[&quot;periodic&quot;]},
    {name:&quot;reorderInterval&quot;, values:[2,3,4]},
    {name:&quot;targetInventory&quot;, startValue:80, endValue:100, stepSize:10},
  ]
};</pre></td></tr></tbody></table><p>Notice that this experiment definition defines 9 experiment scenarios resulting from the combinations of the values 2/3/4 and 80/90/100 for the parameters <i>reorderInterval</i> and <i>targetInventory</i>. Running this parameter variation experiment means running each of the 9 experiment scenarios 10 times (each time with another random seed, as specified by the list of seeds). The resulting statistics, as shown in the following table, is computed by averaging all statistics variables defined for the given model. </p><table border="1" class="expStatistics" id="SimExperiments__simLogTbl"><thead><tr><th colspan="5">Experiment Results</th></tr><tr><th rowspan="2">Experiment scenario</th><th rowspan="2">Parameter values</th><th colspan="3">Statistics</th></tr><tr><th>nmrOfStockOuts</th><th>lostSales</th><th>serviceLevel</th></tr></thead><tbody id="SimExperiments__simLog"><tr><td>0</td><td>periodic,2,80</td><td>21.8</td><td>180.7</td><td>97.82</td></tr><tr><td>1</td><td>periodic,2,90</td><td>7.4</td><td>55.9</td><td>99.26</td></tr><tr><td>2</td><td>periodic,2,100</td><td>2.1</td><td>15.8</td><td>99.79</td></tr><tr><td>3</td><td>periodic,3,80</td><td>86.6</td><td>855.6</td><td>91.34</td></tr><tr><td>4</td><td>periodic,3,90</td><td>40.6</td><td>377.5</td><td>95.94</td></tr><tr><td>5</td><td>periodic,3,100</td><td>16.3</td><td>139.8</td><td>98.37</td></tr><tr><td>6</td><td>periodic,4,80</td><td>171.5</td><td>2067.5</td><td>82.85</td></tr><tr><td>7</td><td>periodic,4,90</td><td>110.6</td><td>1238.3</td><td>88.94</td></tr><tr><td>8</td><td>periodic,4,100</td><td>63.8</td><td>661.4</td><td>93.62</td></tr></tbody></table></section><section><h4>2.6.1. Storage and Export of Experiment Results</h4><p>In OESjs-Core1, an experiment's output statistics data is stored in a browser-managed database using JavaScript's <em>IndexedDB</em> technology. The name of this database is the same as the name of the simulation model. It can be inspected with the help of the browser's developer tools, which are typically activated with the key combination [Shift]+[Ctrl]+[I]. For instance, in Google's <em>Chrome</em> browser, one has to go to Application/Storage/IndexedDB.</p><p>The experiment statistics database consists of three tables containing data about (1) experiment runs, (2) experiment scenarios, and (3) experiment scenario runs, which can be exported to a CSV file. </p><section></section></section></section><section class="role-section1" id="SimLog"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</h2><p>The OESjs-Core1 simulator can generate a simulation log, which allows to inspect the evolving states of a simulation run. Inspecting the simulation log can help to understand the dynamics of a model, or it can be used for finding logical flaws in it.</p><p>The contents of the simulation log can be controlled by defining <em>labels</em> for those object properties that are to be displayed in the log. For instance, in the case of the <a href="https://gwagner57.github.io/oes/js/Core1/Service-Desk-1/index.html" target="_top">Service-Desk-1</a> model, a label &quot;qLen&quot; is defined for the <code>queueLength</code> property of <i>ServiceDesk</i> objects by setting</p><pre>ServiceDesk.labels = {&quot;queueLength&quot;:&quot;qLen&quot;};</pre><p> This results in the following simulation log:</p><table border="1"><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Service-Desk-1{ qLen: 0}</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerDeparture@5, CustomerArrival@6</td></tr><tr><td>2</td><td>5</td><td>Service-Desk-1{ qLen: 0}</td><td>CustomerArrival@6</td></tr><tr><td>3</td><td>6</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerArrival@7, CustomerDeparture@10</td></tr><tr><td>4</td><td>7</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerDeparture@10, CustomerArrival@10</td></tr><tr><td>5</td><td>10</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerArrival@12, CustomerDeparture@13</td></tr><tr><td>6</td><td>12</td><td>Service-Desk-1{ qLen: 3}</td><td>CustomerDeparture@13, CustomerArrival@16</td></tr><tr><td>7</td><td>13</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerArrival@16, CustomerDeparture@16</td></tr><tr><td>8</td><td>16</td><td>Service-Desk-1{ qLen: 2}</td><td>CustomerDeparture@19, CustomerArrival@21</td></tr><tr><td>9</td><td>19</td><td>Service-Desk-1{ qLen: 1}</td><td>CustomerArrival@21, CustomerDeparture@23</td></tr></tbody></table></section></section><section class="role-appendix" id="architecture"><h1 class="role-appendix-title"><span class="role-label">Appendix <span class="role-number">A</span>. </span>Simulator Architecture</h1><p>OES Core 1 adds the following features to OES Core 0:</p><ul><li>fixed-increment time progression</li><li>a seedable random number generator</li><li>a set of sampling functions from various probability distributions (uniform, triangular, normal, exponential, etc.)</li><li>multiple scenarios per model</li><li>multiple experiment types per model</li><li>model parameters</li><li>parameter variation experiments</li><li>persistent storage and export of experiment results</li></ul><p>The OES Core 1 simulator's information architecture is described by the following class diagram, which defines the names of classes, properties and methods/functions:</p><figure><img src="tutorial_files/OES-Core1.svg" /></figure></section><div class="role-backmatter" id="backmatter"><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1><nav class="role-index-toc" id="__I_TOC"><span class="role-index-toc-placeholder">A</span> <span class="role-index-toc-placeholder">B</span> <a class="role-index-div-ref" href="#__I_TOC_C">C</a> <a class="role-index-div-ref" href="#__I_TOC_D">D</a> <a class="role-index-div-ref" href="#__I_TOC_E">E</a> <span class="role-index-toc-placeholder">F</span> <span class="role-index-toc-placeholder">G</span> <span class="role-index-toc-placeholder">H</span> <span class="role-index-toc-placeholder">I</span> <span class="role-index-toc-placeholder">J</span> <span class="role-index-toc-placeholder">K</span> <span class="role-index-toc-placeholder">L</span> <span class="role-index-toc-placeholder">M</span> <span class="role-index-toc-placeholder">N</span> <a class="role-index-div-ref" href="#__I_TOC_O">O</a> <a class="role-index-div-ref" href="#__I_TOC_P">P</a> <span class="role-index-toc-placeholder">Q</span> <a class="role-index-div-ref" href="#__I_TOC_R">R</a> <a class="role-index-div-ref" href="#__I_TOC_S">S</a> <span class="role-index-toc-placeholder">T</span> <span class="role-index-toc-placeholder">U</span> <span class="role-index-toc-placeholder">V</span> <span class="role-index-toc-placeholder">W</span> <span class="role-index-toc-placeholder">X</span> <span class="role-index-toc-placeholder">Y</span> <span class="role-index-toc-placeholder">Z</span></nav><div class="role-index-div" id="__I_TOC_C"><h2 class="role-index-div-title">C<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I2"><span class="role-index-term">continuous dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__2">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_D"><h2 class="role-index-div-title">D<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I3"><span class="role-index-term">discrete dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__3">1</a></span></li><li class="role-index-entry" id="__I4"><span class="role-index-term">discrete event system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__4">1</a></span></li><li class="role-index-entry" id="__I1"><span class="role-index-term">dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__1">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_E"><h2 class="role-index-div-title">E<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ia"><span class="role-index-term">event routine</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__b">1</a></span></li><li class="role-index-entry" id="__I9"><span class="role-index-term">event rule</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__a">1</a></span></li><li class="role-index-entry" id="__I5"><span class="role-index-term">exogenous event</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__5">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_O"><h2 class="role-index-div-title">O<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I8"><span class="role-index-term">occurrence time</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__8">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_P"><h2 class="role-index-div-title">P<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ic"><span class="role-index-term">probability distribution function</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__e">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_R"><h2 class="role-index-div-title">R<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Id"><span class="role-index-term">random number stream</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__f">1</a></span></li><li class="role-index-entry" id="__I7"><span class="role-index-term">random variable</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__7">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__d">2</a></span></li><li class="role-index-entry" id="__I6"><span class="role-index-term">recurrence</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__6">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__9">2</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_S"><h2 class="role-index-div-title">S<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ib"><span class="role-index-term">simultaneous events</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__c">1</a></span></li></ul></div></section></div></section></body></html>