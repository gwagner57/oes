<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Discrete Event Simulation with OESjs-Core0</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="tutorial_files/ebook.css" rel="stylesheet" type="text/css" /><meta content="OES" name="og:site_name" /><meta content="Tutorial: Discrete Event Simulation with OESjs-Core0" name="og:title" /><meta content="en" name="og:locale" /><meta content="This article shows how to create and run a simulation model with the JavaScript-based simulation framework OESjs available on Sim4edu.com. OESjs implements the Object Event Simulation (OES) paradigm, representing a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling." name="og:description" /><meta content="https://gwagner57.github.io/oes/js/Core0/tutorial.html" name="og:url" /><meta content="https://sim4edu.com/img/sim4edu.png" name="og:image" /><meta content="summary_large_image" name="twitter:card" /><style>
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
table.expStatistics tbody td {
    text-align: right;
}

div.role-book-title-div h1.role-book-title {
    margin-bottom: 0.33em;
}
div[id$=&quot;subtitle&quot;] {
    margin-top: 0.33em;
}


div#share {
    display: block; /*inline-block*/
}
ul.links {
    list-style: none;
    padding: 0;
    margin: 0 0 0 1em;
}
ul.links li {
    display: inline;
    text-align: center;
    cursor: pointer;
    margin-right: 1em;
}
ul.links li:hover {
    text-decoration: underline;
}
.icon-social {
    width: 20px;
    height: 20px;
    background: #eee;
}</style></head><body><section class="role-book" id="tutorial"><div class="role-book-title-div"><h1 class="role-book-title">Discrete Event Simulation with OESjs-Core0</h1><div class="role-content" id="tutorial-content-1"><div id="tutorial-content-1__share"> <ul class="links"><li class="share facebook" title="Share on Facebook"><a href="https://www.facebook.com/sharer.php?u=https://gwagner57.github.io/oes/js/Core0/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-facebook" viewBox="0 0 18 18"><path d="M15.7,1.5H2.3c-0.5,0-0.8,0.4-0.8,0.8v13.3c0,0.5,0.4,0.8,0.8,0.8h7.2v-5.8h-2V8.4h2V6.8c0-1.9,1.2-3,2.9-3 c0.8,0,1.5,0.1,1.7,0.1v2l-1.2,0c-0.9,0-1.1,0.4-1.1,1.1v1.4h2.2l-0.3,2.3h-1.9v5.8h3.8c0.5,0,0.8-0.4,0.8-0.8V2.3 C16.5,1.9,16.1,1.5,15.7,1.5z"></path></symbol> <use xlink:href="#social-facebook" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share twitter" title="Share on Twitter"><a href="https://twitter.com/intent/tweet?url=https://gwagner57.github.io/oes/js/Core0/tutorial.html&amp;text=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs-Core0" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-twitter" viewBox="0 0 18 18"><path d="M16.5,4.3c-0.6,0.2-1.1,0.4-1.8,0.5c0.6-0.4,1.1-1,1.4-1.7c-0.6,0.4-1.3,0.6-2,0.8c-0.6-0.6-1.4-1-2.2-1 c-1.7,0-3.1,1.4-3.1,3.1c0,0.2,0,0.5,0.1,0.7C6.3,6.5,4.1,5.3,2.5,3.4C2.3,3.9,2.1,4.4,2.1,5c0,1.1,0.5,2,1.4,2.6 c-0.5,0-1-0.2-1.4-0.4c0,0,0,0,0,0c0,1.5,1.1,2.8,2.5,3.1c-0.3,0.1-0.5,0.1-0.8,0.1c-0.2,0-0.4,0-0.6-0.1c0.4,1.2,1.5,2.1,2.9,2.2 c-1.1,0.8-2.4,1.3-3.8,1.3c-0.2,0-0.5,0-0.7,0c1.4,0.9,3,1.4,4.7,1.4c5.7,0,8.8-4.7,8.8-8.9c0-0.1,0-0.3,0-0.4 C15.6,5.5,16.1,4.9,16.5,4.3"></path></symbol> <use xlink:href="#social-twitter" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share linkedin" title="Share on LinkedIn"><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://gwagner57.github.io/oes/js/Core0/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"> <symbol id="social-linkedin" viewBox="0 0 18 18"><path d="M15.4,1.5H2.6C2,1.5,1.5,2,1.5,2.6v12.8c0,0.6,0.5,1.1,1.1,1.1h12.8c0.6,0,1.1-0.5,1.1-1.1V2.6C16.5,2,16,1.5,15.4,1.5z M3.8,7.1H6v7.2H3.8V7.1z M4.9,6.1c-0.7,0-1.3-0.6-1.3-1.3c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3C6.2,5.6,5.6,6.1,4.9,6.1z M14.5,14.3h-2.3v-3.5c0-0.8,0-1.9-1.2-1.9c-1.2,0-1.4,0.9-1.4,1.8v3.5H7.4V7.1h2.2v1h0c0.3-0.6,1-1.2,2.1-1.2 c2.3,0,2.7,1.5,2.7,3.4V14.3z"></path></symbol> <use xlink:href="#social-linkedin" xmlns:xlink="http://www.w3.org/1999/xlink"></use> </svg></a></li><li class="share email" title="Share with Email"><a aria-label="Share with Email" href="mailto:?subject=Tutorial:%20Discrete%20Event%20Simulation%20with%20OESjs-Core0&amp;body=This%20article%20shows%20how%20to%20create%20and%20run%20a%20simulation%20model%20with%20the%20JavaScript-based%20simulation%20framework%20OESjs-Core0%20available%20on%20Sim4edu.com.%20OESjs-Core0%20implements%20the%20Object%20Event%20Simulation%20paradigm%2C%20representing%20a%20general%20Discrete%20Event%20Simulation%20approach%20based%20on%20object-oriented%20modeling%20and%20event%20scheduling.%0A%0Ahttps://gwagner57.github.io/oes/js/Core0/tutorial.html" target="_blank"><svg aria-hidden="true" class="icon-social" xmlns="http://www.w3.org/2000/svg"><symbol id="social-mail" viewBox="0 0 18 18"><path d="M9,8.2L3,4.5h12L9,8.2z M15,13.5H3V6l6,3.8L15,6V13.5z M15,3H3C2.2,3,1.5,3.7,1.5,4.5l0,9C1.5,14.3,2.2,15,3,15 h12c0.8,0,1.5-0.7,1.5-1.5v-9C16.5,3.7,15.8,3,15,3z"></path></symbol><use xlink:href="#social-mail" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg></a></li></ul> </div><div id="tutorial-content-1__subtitle">How to create and run simulations with the JavaScript-based simulation library <a href="https://gwagner57.github.io/oes/">OESjs-Core0</a> available from the <a href="https://github.com/gwagner57/oes">OES GitHub repo</a></div> <div id="tutorial-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Copyright Â© 2020 Gerd Wagner (<a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC</a>)</p><p>Published 2020-08-17</p><h2>Abstract</h2><p>This tutorial article explains how to use the OESjs-Core0 library, which implements a minimal architecture for an Object Event simulator, supporting model variables, object types, event types, next-event time progression and simple simulation experiments.</p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index"><span class="role-label"><span class="role-number">1</span>. </span>Introduction to Object Event Modeling</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#CM"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#DesM"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-2"><span class="role-label"><span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs-Core0</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimTime"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimModels"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimScenarios"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimStatistics"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimExperiments"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimLog"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-appendix"><a class="role-appendix-ref" href="#architecture"><span class="role-label"><span class="role-number">A</span>. </span>Simulator Architecture</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label"><span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__lof__2"><span class="role-label"><span class="role-number">1-2</span>. </span>A process design model in the form of an Event Graph, where the state variable <i>Q</i> stands for <i>queueLength</i></a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label"><span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#DesM__lof__4"><span class="role-label"><span class="role-number">1-4</span>. </span>A process design model in the form of a DPMN Process Diagram</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-table-ref" href="#SimModels__lot__1"><span class="role-label"><span class="role-number">2-1</span>. </span>Simulation Log</a></li><li class="role-booklist-entry"><a class="role-table-ref" href="#SimStatistics__lot__2"><span class="role-label"><span class="role-number">2-2</span>. </span>Statistics</a></li></ul></section></div><section class="role-chapter" id="index"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling</h1><p>Simulation is used widely today: in many scientific disciplines for investigating specific research questions, in engineering for testing the performance of designs, in education for providing interactive learning experiences, and in entertainment for making games.</p><p>Both static systems/structures and dynamic systems can be modeled and simulated. Modeling and simulation (M&amp;S) of <em>static structures</em>, such as the surface textures of materials, is only an issue in physics and computer graphics, while M&amp;S of dynamic systems is an issue in all scientific and engineering disciplines, including management science, economics and other social sciences.</p><p>A <em>dynamic system</em><a class="role-index-anchor" id="index__I__1"></a> may be subject to discrete or continuous state changes. For simulating a dynamic system one has to model</p><ol><li>the types of objects it is composed of,</li><li>the types of events that cause discrete state changes of objects,</li><li>the discrete state changes of objects caused by the occurrence of an event of some type,</li><li>the follow-up events caused by the occurrence of an event of some type,</li><li>the continuous state changes of objects (described with the help of differential equations).</li></ol><p>A (purely) continuous dynamic system<a class="role-index-anchor" id="index__I__2"></a> does not include events and their causal effects (list items 2-4), but only objects that are subject to continuous state changes (list items 1 and 5). A (purely) discrete dynamic system<a class="role-index-anchor" id="index__I__3"></a> does not include any continuous state changes of objects (list item 5). Many real-world systems include both discrete and continuous state changes, in which case they may be called <em>hybrid</em> dynamic systems.</p><p>In this tutorial, we are only concerned with discrete state changes. Consequently, we only consider purely discrete dynamic systems, also called <em>discrete event systems</em><a class="role-index-anchor" id="index__I__4"></a>, which consist of:</p><ul><li><b>objects</b> (of various types) whose states may be changed by</li><li><b>events</b> (of various types) occurring in a sequence of time points, causing state changes of affected objects and follow-up events.</li></ul><p>This means that for modeling such a system, we have to</p><ol><li>describe its <b>object types</b> and <b>event types</b> (in an <em>information model</em>);</li><li>specify, for any event type, the <b>state changes</b> of objects and the <b>follow-up events</b> caused by the occurrence of an event of that type (in a <em>process model</em>).</li></ol><section class="role-section1" id="CM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Making a Conceptual Model of the System under Investigation</h2><figure class="right"><img alt="" src="tutorial_files/service-desk.svg" width="200" /></figure><p>Let's look at an example. We model a system of one or more service desks, each of them having its own queue, as a discrete event system:</p><ul><li>Customers arrive at a service desk at random times.</li><li>If there is no other customer in front of them, and the service desk is available, they are served immediately, otherwise they have to queue up in a waiting line.</li><li>The duration of services varies, depending on the individual case.</li><li>When a service is completed, the customer departs and the next customer is served, if there is still any customer in the queue.</li></ul><p>The potentially relevant <b>object types</b> of the system under investigation are:</p><ul><li>customers,</li><li>service desks,</li><li>waiting lines,</li><li>service clerks, if the service is performed by (one or more) clerks.</li></ul><p>The potentially relevant <b>event types</b> are:</p><ul><li>customer arrivals,</li><li>service starts,</li><li>service terminations,</li><li>customer departures.</li></ul></section><section class="role-section1" id="DesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Making a Simulation Design Model</h2><p>When making a simulation design based on the conceptual model of the system under investigation, wee need to abstract away from many items of the conceptual model for obtaining a sufficiently simple design. The right degree of abstraction depends on the purpose of the model. But abstracting away from too many things may make a model too unnatural and not sufficiently generic, implying that it cannot be easily extended to model additional features (such as more than one service desk).</p><p>In our example, the purpose of the simulation model is to compute the <em>maximum queue length</em> and possibly also the <em>service utilization</em>. So, we may abstract away from the following object types:</p><ul><li><em>customers</em>: we don't need any information about individual customers.</li><li><em>waiting lines</em>: we don't need to know who is next, it's sufficient to know the length of the queue.</li><li><em>service clerks</em>: we don't need any information about the service clerk(s).</li></ul><p>Notice that, for simplicity, we consider the customer that is currently being served to be part of the queue. In this way, in the simulation program, we can check if the service desk is busy by testing if the length of the queue is greater than 0. In fact, for being able to compute the service utilization and the maximum queue length, the queue length is the only relevant state variable.</p><p>State variables can be modeled in the simple form of <em>global variables</em> or in the form of <em>attributes</em> of suitable object types. Consequently, the simplest model we can make for the given problem, called <em>Service-Desk-0</em>, has only one global variable: <i>queueLength</i>. But, as an alternative, more explicit, model, called <em>Service-Desk-1</em>, we will also model the system state in terms of (one or more) <i>ServiceDesk</i> objects having only one property: <i>queueLength</i>. As opposed to the simpler model defining <i>queueLength</i> as a global variable, this model allows defining simulation scenarios with two or more service desks operating simultaneously.</p><p>We also look for opportunities to simplify our event model by dropping event types that are not needed, e.g., because their events temporally coincide with events of another type. This is the case with <em>service terminations</em> and <i>customer departure</i> events. Consequently, we can drop the event type <em>service terminations</em>.</p><p>There are two situations when a new service can be started: either when the waiting line is empty and a new customer arrives, or when the waiting line is not empty and a service terminates. Therefore, any <em>service start</em> event immediately follows either a <i>customer arrival</i> or a <i>customer departure</i> event, and we may abstract away from <em>service start</em> events and drop the corresponding event type from the design model.</p><p>So we only need to consider <i>customer arrival</i> and <i>customer departure</i> events, modeled with the two event types <i>Arrival</i> and <i>Departure</i>.</p><p>The event type <i>Arrival</i> is an example of a type of <b>exogenous</b> events,<a class="role-index-anchor" id="DesM__I__5"></a> which are not caused by any causal regularity of the system under investigation and, therefore, have to be modeled with a <b>recurrence</b><a class="role-index-anchor" id="DesM__I__6"></a> function that allows to compute the time of the next occurrence of an event of that type. In OES, exogenous event types are a built-in concept such that an OES simulator takes care of creating the next exogenous event whenever an event of that type is processed. This mechanism makes sure that there is a continuous stream of exogenous events throughout a simulation run.</p><p>We also have to model the random variations of two variables: (1) the recurrence of (that is, the time in-between two) customer arrival events and (2) the service duration. In a class model, such random variables<a class="role-index-anchor" id="DesM__I__7"></a> can be defined as special class-level (&quot;static&quot;) operations, with a stereotype Â«rvÂ», in the class to which they belong, as shown in the diagrams below.</p><p>We model the recurrence of customer arrival events as a discrete random variable with a uniform distribution between 1 and 6 minutes, which we express in the class diagram of the information design model by appending the symbolic expression <i>U{1-6}</i> within curly braces to the operation declaration, following the UML syntax for property/method modifiers.</p><p>We model the <i>service time</i> random variable with an empirical distribution of 2 minutes with probability 0.3, 3 minutes with probability 0.5 and 4 minutes with probability 0.2, using the symbolic expression <i>Freq{ 2:0.3, 3:0.5, 4:0.2}</i>.</p><p>Computationally, object types and event types correspond to classes, either of an object-oriented information model, such as a UML class diagram, or of a computer program written in an object-oriented programming language, such as Java or JavaScript.</p><section><h4>1.2.1.Â Service-Desk-0: Modeling <i>queueLength</i> as a global variable</h4><p>As discussed above, the simplest model for the service desk problem with maximum queue length statistics (available in the Sim4edu library as <a href="https://sim4edu.com/sims/14" target="_top">Service-Desk-0</a>) has only one global variable: <i>queueLength</i>, which is a non-negative integer, and a global function for computing the random service time, but no object type.</p><p>An information model for Service-Desk-0 consists of a special class for defining model variables and functions, and two classes for defining the event types <i>Arrival</i> and <i>Departure</i>, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk0"><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</a>.</p><figure id="DesM__figServiceDesk0"><figcaption><span class="role-label">Figure <span class="role-number">1-1</span>. </span>An information design model for Service-Desk-0</figcaption><div><img alt="???" src="tutorial_files/IDM0.svg" width="360" /></div></figure><p>In addition to an information design model for defining the simulation system's state structure, we also need to make a process design model for defining the dynamics of the simulation system. The dynamics of a system consists of events triggering state changes and follow-up events. A process model can be expressed with the help of event rules, which define what happens when an event (of a certain type) occurs, or, more specifically, which state changes and which follow-up events are caused by an event of that type.</p><p>Event rules can be expressed with the help of a process model diagram or in pseudo-code, or in a simulation or programming language. The following <em>Event Graph</em> provides a process design model for the Service-Desk-0 simulation scenario. Circles represent events (or, more precisely, event types) and arrows, which may be annotated with a delay expression, such as +serviceTime(), represent event scheduling relationships. An arrow with a mini-diamond at its source end represents a conditional event scheduling relationship where the condition is expressed in brackets below or above the arrow.</p><figure id="DesM__lof__2"><figcaption><span class="role-label">Figure <span class="role-number">1-2</span>. </span>A process design model in the form of an Event Graph, where the state variable <i>Q</i> stands for <i>queueLength</i></figcaption><div><img alt="???" src="tutorial_files/ServiceDesk0_EG.svg" width="360" /></div></figure><p>Event Graphs have originally been proposed by L. Schruben (<a href="https://dl.acm.org/citation.cfm?id=358460">1983</a>). Their visual syntax has been improved and harmonized with the business process modeling language <em>BPMN</em> in the <em>Discrete Event Process Modeling Notation (DPMN)</em> proposed by Wagner (<a href="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I">2018</a>) and more thoroughly described in the book <a href="https://sim4edu.com/reading/des-engineering/">Discrete Event Simulation Engineering</a>.</p><p>The following table shows the two event rules defined by the above Event Graph, expressed in pseudo-code.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>Arrival @ t</p></td><td><pre>INCREMENT queueLength
IF queueLength = 1 THEN
  sTime := serviceTime()
  SCHEDULE Departure @ (t + sTime)
</pre></td></tr><tr><td><p>Departure @ t</p></td><td><pre>DECREMENT queueLength
IF queueLength &gt; 0 THEN
  sTime := serviceTime()
  SCHEDULE Departure @ (t + sTime)</pre></td></tr></tbody></table></section> <section><h4>1.2.2.Â Service-Desk-1: Modeling <i>queueLength</i> as an attribute</h4><p>In our extended model (<a href="https://sim4edu.com/sims/1" target="_top">Service-Desk-1</a>) we represent the state variable <i>queueLength</i> as an attribute of an object type <i>ServiceDesk</i>. This results in a model with three classes, the object class <i>ServiceDesk</i> with an attribute <i>queueLength</i>, and the event classes <i>Arrival</i> and <i>Departure</i>, both with a reference property <i>serviceDesk</i> for referencing the service desk at which an event occurs. When we also want to compute the service utilization statistics, we need to add an attribute <i>serviceTime</i> to the <i>Departure</i> class for being able to update the service utilization statistics when a customer departs.</p><p>Both event types, <i>Arrival</i> and <i>Departure</i>, now have a many-to-one association with the object type <i>ServiceDesk</i>. This expresses the fact that any such event occurs at a particular service desk, which participates in the event. This association is implemented in the form of a reference property <i>serviceDesk</i> in each of the two event types, as shown in <a class="role-figure-ref" href="#DesM__figServiceDesk1"><span class="role-label">Figure <span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</a>.</p><figure id="DesM__figServiceDesk1"><figcaption><span class="role-label">Figure <span class="role-number">1-3</span>. </span>An information design model for Service-Desk-1</figcaption><div><img alt="???" src="tutorial_files/IDM1.svg" width="400" /></div></figure><p>In addition to an information model, we need to make a process model, which captures the dynamics of the service desk system consisting of arrival and departure events triggering state changes and follow-up events. The following <em>DPMN Process Diagram</em> provides a process design model for the Service-Desk-1 simulation scenario. As in Event Graphs, circles represent event types and arrows represent event scheduling relationships. DPMN extends Event Graphs by adding object rectangles, attached to event circles, representing state change patterns for objects that are affected by events of that type.</p><figure id="DesM__lof__4"><figcaption><span class="role-label">Figure <span class="role-number">1-4</span>. </span>A process design model in the form of a DPMN Process Diagram</figcaption><div><img alt="???" src="tutorial_files/ServiceDesk-1_PDM.svg" width="600" /></div></figure><p>The following table shows the two event rules defined by the DPMN diagram, which now account for the fact that both types of events occur at a particular service desk that is referenced by the event expression parameter <i>sd</i>.</p><table border="1" style="border-spacing:3px;width:100%;"><thead><tr><td style="text-align:center;"><p><b>ON (event type)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>Arrival( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>INCREMENT sd.queueLength
IF sd.queueLength = 1 THEN
  sTime := ServiceDesk.serviceTime()
  SCHEDULE Departure( sTime, sd) @(t + sTime)
</pre></td></tr><tr><td><p>Departure( sd) @ t</p><p>with sd : ServiceDesk</p></td><td><pre>DECREMENT sd.queueLength
IF sd.queueLength &gt; 0 THEN
  sTime := ServiceDesk.serviceTime()
  SCHEDULE Departure( sTime, sd) @(t + sTime)</pre></td></tr></tbody></table></section></section></section><section class="role-chapter" id="index-2"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Creating Object Event Simulations with OESjs-Core0</h1><p>The JavaScript-based simulator <i>OESjs-Core0</i> implements the <i>Object Event Simulation (<a href="https://sim4edu.com/OES" target="_top">OES</a>)</i> paradigm, representing a general <i>Discrete Event Simulation</i> approach based on <i>object-oriented</i> modeling and <i>event scheduling</i>. In OES, a model normally defines various types of objects and events, but OESjs-Core0 also supports models without objects, if they define state variables in the form of global <i>model variables</i>, instead.</p><p>An OESjs-Core0 simulation consists of the OESjs-Core0 library code and the following files to be created by the simulation developer:</p><ol><li>For each object type <i>ObjT</i>, a JS code file <kbd>ObjT.js</kbd>.</li><li>For each event type <i>EvtT</i>, a JS code file <kbd>EvtT.js</kbd>.</li><li>A <kbd>simulation.js</kbd> file defining further parts of the simulation, such as statistics variables and the initial state.</li></ol><p>OESjs-Core0 supports two forms of simulations:</p><ol><li><p>Standalone scenario simulations, which are good for getting a quick impression of a simulation model, e.g., by checking some simple statistics.</p></li><li><p>Simple simulation experiments, which are defined as a set of replicated simulation scenario runs, providing summary statistics like mean, standard deviation, minimum/maximum and confidence intervals for each statistics variable defined in the underlying model.</p></li></ol><p>Using a simulation library like OESjs-Core0 means that only the model-specific logic has to be coded (in the form of object types, event types, event routines and other functions for model-specific computations), but not the general simulator operations (e.g., time progression and statistics) and the environment handling (e.g., user interfaces for statistics output).</p><p>The following sections present the basic concepts of the OESjs<i>-Core0</i> simulation library, and show how to implement the service desk models described in <a class="role-chapter-ref" href="#index"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Object Event Modeling</a>.</p><blockquote class="role-attention"><p>While you can directly run a OESjs Core1 simulation model from a remote website (e.g., from the OES GitHub website), you can only run it from your local file system after changing your browser's default configuration. For FireFox, you have to set the configuration property <code>privacy.file_unique_origin</code> to <i>false</i> by entering <code>about:config</code> in the browser's web address bar.</p></blockquote><section class="role-section1" id="SimTime"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Simulation Time</h2><p>A simulation model has an underlying <b><i>time model</i></b>, which can be either <i>discrete time</i>, when setting</p><pre>sim.model.time = &quot;discrete&quot;;</pre><p>or <i>continuous time</i>, when setting</p><pre>sim.model.time = &quot;continuous&quot;;</pre><p>Choosing a discrete time model means that time is measured in steps (with equal durations), and all temporal random variables used in the model need to be discrete (i.e., based on discrete probability distributions). Choosing a continuous time model means that one has to define a <i>simulation time granularity</i>, as explained in the next sub-section.</p><p>In both cases, the underlying simulation <b><i>time unit</i></b> can be either left unspecified (e.g., in the case of an abstract time model), or it can be set to one of the time units &quot;ms&quot;, &quot;s&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;, &quot;month&quot; or &quot;year&quot;, as in</p><pre>sim.model.timeUnit = &quot;hour&quot;;</pre><p>Typical examples of time models are:</p><ol><li><p>An abstract discrete model of time where time runs in steps without any concrete meaning: </p><pre>sim.model.time = &quot;discrete&quot;;</pre></li><li><p>A concrete discrete model of time in number of days: </p><pre>sim.model.time = &quot;discrete&quot;;
sim.model.timeUnit = &quot;day&quot;;</pre></li><li><p>A concrete continuous model of time in number of seconds: </p><pre>sim.model.time = &quot;continuous&quot;;
sim.model.timeUnit = &quot;s&quot;;</pre></li></ol><section><h4>2.1.1. Time Granularity</h4><p>A model's <em>time granularity</em> is the time delay until the next moment, such that the model does not allow considering an earlier next moment. This is captured by the simulation parameter <i>nextMomentDeltaT</i> used by the simulator for scheduling immediate events with a minimal delay. When a simulation model is based on discrete time, <i>nextMomentDeltaT</i> is set to 1, referring to the next time point. When a simulation model is based on continuous time, <i>nextMomentDeltaT</i> is set to the default value 0.001, unless the model parameter <code>sim.model.nextMomentDeltaT</code> is explicitly assigned in the <kbd>simulation.js</kbd> file.</p></section><section><h4>2.1.2. Time Progression</h4><p>An important issue in simulation is the question how the simulation time is advanced by the simulator. The OES paradigm supports <strong>next-event</strong> time progression and <strong>fixed-increment</strong> time progression, as well as their combination.</p><p>An OESjs-Core0 model with fixed-increment time progression has to define a suitable periodic time event type, like <code>EachSecond</code> or <code>EachDay</code> in the form of an exogenous event type with a recurrence function returning the value 1. Such a model can be used for</p><ol><li>modeling continuous state changes (e.g., objects moving in a continuous space), or</li><li>making a discrete model that abstracts away from explicit events and uses only implicit periodic time events (&quot;ticks&quot;), which is a popular approach in social science simulation.</li></ol><p>Examples of discrete event simulation models with fixed-increment time progression and no explicit events are the <a href="https://sim4edu.com/sims/6">Schelling Segregation Model</a> and the <a href="https://sim4edu.com/sims/25/index.html">Susceptible-Infected-Recovered (SIR) Disease Model</a>.</p></section></section><section class="role-section1" id="SimModels"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Simulation Models</h2><section><h4>2.2.1. Model Variables and Functions</h4><p>In the simple model of a service desk discussed in the previous section, we define one (global) model variable, <i>queueLength</i>, one model function, <i>serviceTime</i>(), and two event types, as shown in the following class diagram: </p><figure><img alt="???" src="tutorial_files/IDM0.svg" width="400" /></figure><p>Notice that this model does not define any object type, which implies that the system state is not composed of the states of objects, but of the states of model variables (here the state of the model variable <i>queueLength</i>). The discrete random variable for modeling the random variation of service durations is implemented as a model function <code>serviceTime</code> shown in the <i>Global Variables and Functions</i> class. It samples integers between 2 and 4 from the empirical probability distribution <i>Frequency{ 2:0.3, 3:0.5, 4:0.2}</i>. The model can be coded with OESjs-Core0 in the following way:</p><pre>// (global) model variable
sim.model.v.<strong>queueLength</strong> = 0;
// (global) model function
sim.model.f.<strong>serviceTime</strong> = function () {
  var r = math.getUniformRandomInteger( 0, 99);
  if ( r &lt; 30) return 2;         // probability 0.30
  else if ( r &lt; 80) return 3;    // probability 0.50
  else return 4;                 // probability 0.20
};</pre><p>You can <a href="https://gwagner57.github.io/oes/js/Core0/Service-Desk-0/index.html" target="_top">run this Service-Desk-0 model</a> from the project's GitHub website. An example of a run of this model is shown in the following simulation log: </p><table border="1" id="SimModels__lot__1"><caption><span class="role-label">Table <span class="role-number">2-1</span>. </span>Simulation Log</caption><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody id="SimModels__simLog"><tr><td>0</td><td>0</td><td>queueLength: 0</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>queueLength: 1</td><td>CustomerDeparture@4, CustomerArrival@4</td></tr><tr><td>2</td><td>4</td><td>queueLength: 1</td><td>CustomerDeparture@6, CustomerArrival@7</td></tr><tr><td>3</td><td>6</td><td>queueLength: 0</td><td>CustomerArrival@7</td></tr><tr><td>4</td><td>7</td><td>queueLength: 1</td><td>CustomerDeparture@11, CustomerArrival@13</td></tr><tr><td>5</td><td>11</td><td>queueLength: 0</td><td>CustomerArrival@13</td></tr><tr><td>6</td><td>13</td><td>queueLength: 1</td><td>CustomerDeparture@15, CustomerArrival@19</td></tr><tr><td>7</td><td>15</td><td>queueLength: 0</td><td>CustomerArrival@19</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>49</td><td>114</td><td>queueLength: 0</td><td>CustomerArrival@117</td></tr><tr><td>50</td><td>117</td><td>queueLength: 1</td><td>CustomerArrival@118, CustomerDeparture@119</td></tr><tr><td>51</td><td>118</td><td>queueLength: 2</td><td>CustomerDeparture@119, CustomerArrival@119</td></tr><tr><td>52</td><td>119</td><td>queueLength: 2</td><td>CustomerArrival@121, CustomerDeparture@123</td></tr><tr><td>53</td><td>121</td><td>queueLength: 3</td><td>CustomerDeparture@123, CustomerArrival@124</td></tr><tr><td>54</td><td>123</td><td>queueLength: 2</td><td>CustomerArrival@124, CustomerDeparture@126</td></tr><tr><td>55</td><td>124</td><td>queueLength: 3</td><td>CustomerArrival@125, CustomerDeparture@126</td></tr><tr><td>56</td><td>125</td><td>queueLength: 4</td><td>CustomerDeparture@126, CustomerArrival@128</td></tr><tr><td>57</td><td>126</td><td>queueLength: 3</td><td>CustomerArrival@128, CustomerDeparture@128</td></tr><tr><td>58</td><td>128</td><td>queueLength: 3</td><td>CustomerArrival@129, CustomerDeparture@131</td></tr><tr><td>59</td><td>129</td><td>queueLength: 4</td><td>CustomerDeparture@131, CustomerArrival@133</td></tr><tr><td>60</td><td>131</td><td>queueLength: 3</td><td>CustomerArrival@133, CustomerDeparture@135</td></tr><tr><td>61</td><td>133</td><td>queueLength: 4</td><td>CustomerDeparture@135, CustomerArrival@137</td></tr><tr><td>62</td><td>135</td><td>queueLength: 3</td><td>CustomerArrival@137, CustomerDeparture@137</td></tr><tr><td>63</td><td>137</td><td>queueLength: 3</td><td>CustomerArrival@139, CustomerDeparture@141</td></tr><tr><td>64</td><td>139</td><td>queueLength: 4</td><td>CustomerDeparture@141, CustomerArrival@142</td></tr><tr><td>65</td><td>141</td><td>queueLength: 3</td><td>CustomerArrival@142, CustomerDeparture@144</td></tr><tr><td>66</td><td>142</td><td>queueLength: 4</td><td>CustomerDeparture@144, CustomerArrival@147</td></tr><tr><td>67</td><td>144</td><td>queueLength: 3</td><td>CustomerArrival@147, CustomerDeparture@148</td></tr><tr><td>68</td><td>147</td><td>queueLength: 4</td><td>CustomerDeparture@148, CustomerArrival@148</td></tr><tr><td>69</td><td>148</td><td>queueLength: 4</td><td>CustomerArrival@149, CustomerDeparture@151</td></tr><tr><td>70</td><td>149</td><td>queueLength: 5</td><td>CustomerDeparture@151, CustomerArrival@151</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table></section><section><h4>2.2.2. Object Types</h4><p>Object types are defined in the form of classes. Consider the object type <i>ServiceDesk</i> defined in the following <i>Service-Desk-1</i> model: </p><figure><img alt="???" src="tutorial_files/IDM1.svg" width="400" /></figure><p>While <code>queueLength</code> was defined as a global variable in the <i>Service-Desk-0</i> model, it is now defined as an attribute of the object type <i>ServiceDesk</i>:</p><pre>class <b>ServiceDesk</b> extends oBJECT {
  constructor({ id, name, queueLength}) {
    super( id, name);
    this.<b>queueLength</b> = queueLength;
  }
  static <b>serviceTime</b>() {
    var r = math.getUniformRandomInteger( 0, 99);
    if ( r &lt; 30) return 2;         // probability 0.3
    else if ( r &lt; 80) return 3;    // probability 0.5
    else return 4;                 // probability 0.2
  }
}
ServiceDesk.<b>labels</b> = {&quot;queueLength&quot;:&quot;qLen&quot;};  // for the log</pre><p>Notice that, in OESjs, object types are defined as subtypes of the pre-defined class <code>oBJECT</code>, from which they inherit an integer-valued <code>id</code> attribute and an optional <code>name</code> attribute. When a property has a <code>label</code> (defined by the class-level (map-valued) property <code>labels</code>), it is shown in the simulation log.</p><p>You can <a href="https://gwagner57.github.io/oes/js/Core0/Service-Desk-1/index.html" target="_top">run this <i>simulation</i> model</a> from the project's GitHub website.</p></section><section><h4>2.2.3. Event Types</h4><p>In OES, there is a distinction between two kinds of events:</p><ol><li>events that are <em>caused</em> by other event occurrences during a simulation run;</li><li><em>exogenous</em> events that seem to happen spontaneously, but may be caused by factors, which are external to the simulation model.</li></ol><p>Here is an example of an exogenous event type definition in OESjs-Core0:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.<b>serviceDesk</b> = serviceDesk;
  }
  <b>onEvent</b>() {
    ...
  }
  ...
}</pre><p>The definition of the <i>CustomerArrival</i> event type includes a reference property <i>serviceDesk</i>, which is used for referencing the service desk object at which a customer arrival event occurs. In OESjs, event types are defined as subtypes of the pre-defined class <code>eVENT</code>, from which they inherit an attribute <code>occTime</code>, which holds the occurrence time<a class="role-index-anchor" id="SimModels__I__8"></a> of an event. As opposed to objects, events do normally not have an ID, nor a name. </p><p>Each event type needs to define an <code>onEvent</code> method that implements the event rule for events of the defined type. Event rules are discussed below. </p><p>Exogenous events occur periodically. They are therefore defined with a <em>recurrence</em> function,<a class="role-index-anchor" id="SimModels__I__9"></a> which provides the time in-between two events (often in the form of a random variable). The recurrence function is defined as a class-level (&quot;static&quot;) method:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  static <b>recurrence</b>() {
    return math.getUniformRandomInteger( 1, 6);
  }
}</pre><p>Notice that the <i>recurrence</i> function of <i>CustomerArrival</i> is coded with the library method <code class="code">math.getUniformRandomInteger</code>, which allows sampling from discrete uniform probability distribution functions. </p><p>In the case of an exogenous event type definition, a <i>createNextEvent</i> method has to be defined for assigning event properties and returning the next event of that type, which is scheduled by invoking the <i>recurrence</i> function for setting its <i>ocurrenceTime</i> and by copying all participant references (such as the <i>serviceDesk</i> reference). </p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  <b>createNextEvent</b>() {
    return new CustomerArrival({
      occTime: this.occTime + CustomerArrival.<b>recurrence</b>(),
      serviceDesk: this.serviceDesk
    });
  }
  static <b>recurrence</b>() {...}
}</pre><p>The second event type of the <i>Service-Desk-1</i> model, <i>Departure</i>, is an example of a type of <i>caused</i> events:</p><pre>class <b>CustomerDeparture</b> extends eVENT {
  constructor({ occTime, serviceDesk}) {
    super( occTime);
    this.serviceDesk = serviceDesk;
  }
  onEvent() {
    ...
  }
}</pre><p>A caused event type does neither define a <i>recurrence</i> function nor a <i>createNextEvent</i> method.</p></section><section><h4>2.2.4. Event Rules</h4><p>An event rule<a class="role-index-anchor" id="SimModels__I__a"></a> for an event type defines what happens when an event of that type occurs, by specifying the caused state changes and follow-up events. In OESjs, event rules are coded as <code>onEvent</code> methods of the class that implements the event type. These methods return a set of events (more precisely, a set of JS objects representing events).</p><p>Notice that in the DES literature, event rule methods are called <i>event routines</i><a class="role-index-anchor" id="SimModels__I__b"></a>.</p><p>For instance, in the <code>CustomerArrival</code> class, the following event rule method is defined:</p><pre>class <b>CustomerArrival</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // increment queue length due to newly arrived customer
    this.serviceDesk.<b>queueLength</b>++;
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    // if the service desk is not busy
    if (this.serviceDesk.queueLength === 1) {
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre><p>The context of this event rule method is the event that triggers the rule, that is, the variable <code>this</code> references a JS object that represents the triggering event. Thus, the expression <code>this.serviceDesk</code> refers to the service desk object associated with the current customer arrival event, and the statement <code>this.serviceDesk.queueLength++</code> increments the <i>queueLength</i> attribute of this service desk object (as an immediate state change).</p><p>The following event rule method is defined in the <code>CustomerDeparture</code> class. </p><pre>class <b>CustomerDeparture</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    var followupEvents=[];
    // decrement queue length due to departure
    this.serviceDesk.<b>queueLength</b>--;
    // update statistics
    sim.stat.<b>departedCustomers</b>++;
    // if there are still customers waiting
    if (this.serviceDesk.queueLength &gt; 0) {
      // start next service and schedule its end/departure
      followupEvents.push( <b>new CustomerDeparture</b>({
        occTime: this.occTime + ServiceDesk.serviceTime(),
        serviceDesk: this.serviceDesk
      }));
    }
    return followupEvents;
  }
}</pre></section><section><h4>2.2.6. Library Methods for Sampling from Probability Distribution Functions</h4><p>Random variables<a class="role-index-anchor" id="SimModels__I__c"></a> are implemented as functions that sample from specific <em>probability distribution functions (PDFs)</em>.<a class="role-index-anchor" id="SimModels__I__d"></a> Simulation frameworks typically provide a library of predefined parametrized PDF sampling methods, which can be bound to a (possibly seeded) stream of <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_top">pseudo-random numbers</a>.</p><p>The OESjs-Core0 simulator does not support seeding and provides only two predefined parametrized PDF sampling functions:</p><table border="1"><thead><tr><td style="text-align:center;"><b>Probability Distribution Function</b></td><td style="text-align:center;"><b>OES-Core-0 Library Method</b></td><td style="text-align:center;"><b>Example</b></td></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" target="_top">Uniform</a></td><td><code>getUniformRandomNumber</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>math.getUniformRandomNumber( 0.5, 1.5)</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution" target="_top">Discrete Uniform</a></td><td><code>getUniformRandomInteger</code>( <i>lowerBound</i>, <i>upperBound</i>)</td><td><code>math.getUniformRandomInteger( 1, 6)</code></td></tr></tbody></table></section></section><section class="role-section1" id="SimScenarios"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.3</span>. </span>Simulation Scenarios</h2><p>For obtaining a complete executable simulation scenario, a simulation model has to be complemented with <em>simulation parameter settings</em> and an <em>initial system state</em>.</p><p>In general, we may have more than one simulation scenario for a simulation model. For instance, the same model could be used in two different scenarios with different initial states. However, only from OES Core 1 upwards, multiple scenarios per model will be supported.</p><p>A <em>simulation scenario</em> consists of</p><ol><li>a simulation model,</li><li>simulation parameter settings, such as setting a value for <code>durationInSimTime</code>, and</li><li>an initial state definition.</li></ol><p>An empty template for the <kbd>simulation.js</kbd> file has the following structure:</p><pre>// ***** Simulation Model *******************
sim.model.time = &quot;...&quot;;  // discrete or continuous
sim.model.timeIncrement = ...;   // optional
sim.model.timeUnit = &quot;...&quot;;  // optional (ms|s|min|hour|day|week|month|year)
sim.model.v.aModelVariable = ...;  // (developer-defined) model variables
sim.model.f.aModelFunction = ...;  // (developer-defined) model functions
sim.model.objectTypes = [...];  // (developer-defined) object types
sim.model.eventTypes = [...];  // (developer-defined) event types
// ***** Simulation Parameters **************
sim.scenario.durationInSimTime = ...;
// ***** Initial State **********************
sim.scenario.<b>setupInitialState</b> = function () {
  // Initialize model variables
  ...
  // Create initial objects
  ...
  // Schedule initial events
  ...
};
// ***** Ex-Post Statistics *****************
sim.model.statistics = {...};</pre><p>We briefly discuss each group of scenario information items in the following sub-sections.</p><section><h4>2.3.1. Simulation Scenario Parameters</h4><p>In OESjs-Core0, the only simulation parameter is <i>durationInSimTime</i>, which defines the duration of a simulation run in terms of simulation time. By default, when this attribute is not set, the simulation runs forever.</p></section><section id="SimScenarios__sectInitialState"><h4>2.3.2. Initial State</h4><p>Defining an initial state means:</p><ol><li>assigning initial values to global model variables, if there are any;</li><li>defining which objects exist initially, and assigning initial values to their properties;</li><li>defining which events are scheduled initially.</li></ol><p>A <code>setupInitialState</code> procedure takes care of these initial state definitions. A global model variable is initialized in the following way: </p><pre>sim.scenario.setupInitialState = function () {
  // <b>Initialize model variables</b>
  <b>sim.model.v.queueLength</b> = 0;
  // Create initial objects
  ...
  // Schedule initial events
  ...
};</pre><p>An initial state object is created by instantiating an object type of the simulation model with suitable initial property values, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // <b>Create initial objects</b>
  let <b>serviceDesk1</b> = new ServiceDesk({id: 1, queueLength: 0});
  // Schedule initial events
  ...
};</pre><p>Notice that object IDs are positive integers, but when used as keys in the map <code>sim.objects</code>, they are converted to strings.</p><p>Instead of assigning a <strong>fixed value</strong> to a property like <code>queueLength</code> for defining an object's initial state, as in <code>queueLength: 0</code>, we can also assign it a <strong>fixed expression</strong>, as in <code>queueLength: Math.round(12/30)</code>.</p><p>An <strong>initial event</strong> is scheduled by adding it to the <em>Future Events List (FEL)</em>, as shown in the following example:</p><pre>sim.scenario.setupInitialState = function () {
  // Initialize model variables
  ...
  // Create initial objects
  let desk1 = new ServiceDesk({id: 1, queueLength: 0});
  // <b>Schedule initial events</b>
  sim.<b>FEL.add</b>( <b>new CustomerArrival</b>({occTime:1, serviceDesk: desk1}));
};</pre></section><section><h4>2.3.3. Using Model Parameters in the Initial State</h4><p>Initial objects or events can be parametrized with the help of model parameters.</p></section></section><section class="role-section1" id="SimStatistics"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.4</span>. </span>Statistics</h2><p>In scientific and engineering simulation projects the main goal is getting estimates of the values of certain variables or performance indicators with the help of statistical methods. In educational simulations, statistics can be used for observing simulation runs and for learning the dynamics of a simulation model. </p><p>For collecting statistics, suitable <em>statistics variables</em> have to be defined, as in the following example:</p><pre>sim.model.<b>setupStatistics</b> = function () {
  sim.stat.arrivedCustomers = 0;
  sim.stat.departedCustomers = 0;
  sim.stat.maxQueueLength = 0;
};</pre><p>Statistics variables have to be updated in <i>onEvent</i> methods. For instance, the variables <i>arrivedCustomers</i> and <i>maxQueueLength</i> are updated in the onEvent method of the <i>CustomerArrival</i> event class:</p><pre>class CustomerArrival extends eVENT {
  ...
  onEvent() {
    ...
    // update statistics
    sim.stat.<b>arrivedCustomers</b>++;
    if (this.serviceDesk.queueLength &gt; sim.stat.maxQueueLength) {
      sim.stat.<b>maxQueueLength</b> = this.serviceDesk.queueLength;
    }
    ...
  }
}</pre><p>In certain cases, a statistics variable can only be computed at the end of a simulation run. For this purpose, there is the option to define a <i>computeFinalStatistics</i> procedure:</p><pre>sim.model.<b>computeFinalStatistics</b> = function () {
  // percentage of business days without stock-outs
  sim.stat.serviceLevel = (sim.time - sim.stat.nmrOfStockOuts) / sim.time * 100;
};</pre><p>After running a simulation scenario, the statistics results are shown in a table:</p><table border="1" id="SimStatistics__lot__2"><caption><span class="role-label">Table <span class="role-number">2-2</span>. </span>Statistics</caption><tbody><tr><td>arrivedCustomers</td><td>289</td></tr><tr><td>departedCustomers</td><td>288</td></tr><tr><td>maxQueueLength</td><td>4</td></tr></tbody></table></section><section class="role-section1" id="SimExperiments"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.5</span>. </span>Simulation Experiments</h2><p>There are different types of simulation experiments. In the simplest case, a simulation scenario is run repeatedly for being able to compute aggregate statistics.</p><p>An experiment type is defined for a given simulation model and an experiment of that type is run on top of a given simulation scenario for that model.</p><p>A simple experiment type is defined with a <code>sim.experimentType</code> record on top of a model by defining (1) the number of <em>replications</em> and (2) possibly a list of <em>seed values</em>, one for each replication. The following code shows an example of a simple experiment type definition:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.experimentType = {
  title: &quot;Simple Experiment with 10 replications, each running for 1000 time units (days)&quot;,
  nmrOfReplications: 10
};</pre></td></tr></tbody></table><p>Running this simple experiment means running the underlying scenario 10 times. The resulting statistics are composed of the statistics for each replication complemented with summary statistics listing averages, standard deviations, min/max values and confidence intervals, as shown in the following table:</p><table border="1" style="overflow-x: auto;"><thead><tr><th colspan="4">Experiment Results</th></tr><tr><th rowspan="2">Replication</th><th colspan="3">Statistics</th></tr><tr><th>arrivedCustomers</th><th>departedCustomers</th><th>maxQueueLength</th></tr></thead><tbody><tr><td>1</td><td>285</td><td>283</td><td>7</td></tr><tr><td>2</td><td>274</td><td>274</td><td>6</td></tr><tr><td>3</td><td>285</td><td>285</td><td>4</td></tr><tr><td>4</td><td>287</td><td>286</td><td>5</td></tr><tr><td>5</td><td>284</td><td>284</td><td>6</td></tr><tr><td>6</td><td>300</td><td>299</td><td>4</td></tr><tr><td>7</td><td>288</td><td>286</td><td>5</td></tr><tr><td>8</td><td>286</td><td>284</td><td>4</td></tr><tr><td>9</td><td>286</td><td>285</td><td>4</td></tr><tr><td>10</td><td>295</td><td>293</td><td>6</td></tr><tr><td>Average</td><td>287</td><td>285.9</td><td>5.1</td></tr><tr><td>Std.dev.</td><td>6.848</td><td>6.506</td><td>1.101</td></tr><tr><td>Minimum</td><td>274</td><td>274</td><td>4</td></tr><tr><td>Maximum</td><td>300</td><td>299</td><td>7</td></tr><tr><td>CI Lower</td><td>282.9</td><td>281.9</td><td>4.4</td></tr><tr><td>CI Upper</td><td>291</td><td>289.6</td><td>5.7</td></tr></tbody></table></section><section class="role-section1" id="SimLog"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.6</span>. </span>Using the Simulation Log</h2><p>The OESjs-Core0 simulator can generate a simulation log, which allows to inspect the evolving states of a simulation run. Inspecting the simulation log can help to understand the dynamics of a model, or it can be used for finding logical flaws in it.</p><p>The contents of the simulation log can be controlled by defining <em>labels</em> for those object properties that are to be displayed in the log. For instance, in the case of the <a href="https://gwagner57.github.io/oes/js/Core0/Service-Desk-1/index.html" target="_top">Service-Desk-1</a> model, a label &quot;qLen&quot; is defined for the <code>queueLength</code> property of <i>ServiceDesk</i> objects by setting</p><pre>ServiceDesk.labels = {&quot;queueLength&quot;:&quot;qLen&quot;};</pre><p> This results in the following simulation log:</p><table border="1"><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>ServiceDesk-1{ qLen: 0}</td><td>CustomerArrival@1</td></tr><tr><td>1</td><td>1</td><td>ServiceDesk-1{ qLen: 1}</td><td>CustomerDeparture@5, CustomerArrival@6</td></tr><tr><td>2</td><td>5</td><td>ServiceDesk-1{ qLen: 0}</td><td>CustomerArrival@6</td></tr><tr><td>3</td><td>6</td><td>ServiceDesk-1{ qLen: 1}</td><td>CustomerArrival@7, CustomerDeparture@10</td></tr><tr><td>4</td><td>7</td><td>ServiceDesk-1{ qLen: 2}</td><td>CustomerDeparture@10, CustomerArrival@10</td></tr><tr><td>5</td><td>10</td><td>ServiceDesk-1{ qLen: 2}</td><td>CustomerArrival@12, CustomerDeparture@13</td></tr><tr><td>6</td><td>12</td><td>ServiceDesk-1{ qLen: 3}</td><td>CustomerDeparture@13, CustomerArrival@16</td></tr><tr><td>7</td><td>13</td><td>ServiceDesk-1{ qLen: 2}</td><td>CustomerArrival@16, CustomerDeparture@16</td></tr><tr><td>8</td><td>16</td><td>ServiceDesk-1{ qLen: 2}</td><td>CustomerDeparture@19, CustomerArrival@21</td></tr><tr><td>9</td><td>19</td><td>ServiceDesk-1{ qLen: 1}</td><td>CustomerArrival@21, CustomerDeparture@23</td></tr></tbody></table></section></section><section class="role-appendix" id="architecture"><h1 class="role-appendix-title"><span class="role-label">Appendix <span class="role-number">A</span>. </span>Simulator Architecture</h1><p>OES Core 0 is the minimal architecture for an OE simulator, supporting</p><ul><li>model variables</li><li>object types and event types, including <em>exogenous</em> event types with <code>recurrence</code> and <code>nextEvent</code> functions</li><li>next-event time progression</li><li>the uniform distribution as the only representative of probability distributions</li><li>simple simulation experiments with the (unseeded) random number generator provided by the host programming language.</li></ul><p>The OES Core 0 simulator's information architecture is described by the following class diagram, which defines the names of classes, properties and methods/functions:</p><figure><img src="tutorial_files/OES-Core0.svg" /></figure><p>The Run-Standalone-Scenario procedure is described by the following activity diagram:</p><figure><img src="tutorial_files/OES-Core0-runStandaloneScenario.svg" /></figure></section><div class="role-backmatter" id="backmatter"><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1><nav class="role-index-toc" id="__I_TOC"><span class="role-index-toc-placeholder">A</span> <span class="role-index-toc-placeholder">B</span> <a class="role-index-div-ref" href="#__I_TOC_C">C</a> <a class="role-index-div-ref" href="#__I_TOC_D">D</a> <a class="role-index-div-ref" href="#__I_TOC_E">E</a> <span class="role-index-toc-placeholder">F</span> <span class="role-index-toc-placeholder">G</span> <span class="role-index-toc-placeholder">H</span> <span class="role-index-toc-placeholder">I</span> <span class="role-index-toc-placeholder">J</span> <span class="role-index-toc-placeholder">K</span> <span class="role-index-toc-placeholder">L</span> <span class="role-index-toc-placeholder">M</span> <span class="role-index-toc-placeholder">N</span> <a class="role-index-div-ref" href="#__I_TOC_O">O</a> <a class="role-index-div-ref" href="#__I_TOC_P">P</a> <span class="role-index-toc-placeholder">Q</span> <a class="role-index-div-ref" href="#__I_TOC_R">R</a> <span class="role-index-toc-placeholder">S</span> <span class="role-index-toc-placeholder">T</span> <span class="role-index-toc-placeholder">U</span> <span class="role-index-toc-placeholder">V</span> <span class="role-index-toc-placeholder">W</span> <span class="role-index-toc-placeholder">X</span> <span class="role-index-toc-placeholder">Y</span> <span class="role-index-toc-placeholder">Z</span></nav><div class="role-index-div" id="__I_TOC_C"><h2 class="role-index-div-title">C<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I2"><span class="role-index-term">continuous dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__2">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_D"><h2 class="role-index-div-title">D<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I3"><span class="role-index-term">discrete dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__3">1</a></span></li><li class="role-index-entry" id="__I4"><span class="role-index-term">discrete event system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__4">1</a></span></li><li class="role-index-entry" id="__I1"><span class="role-index-term">dynamic system</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#index__I__1">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_E"><h2 class="role-index-div-title">E<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ia"><span class="role-index-term">event routine</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__b">1</a></span></li><li class="role-index-entry" id="__I9"><span class="role-index-term">event rule</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__a">1</a></span></li><li class="role-index-entry" id="__I5"><span class="role-index-term">exogenous event</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__5">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_O"><h2 class="role-index-div-title">O<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I8"><span class="role-index-term">occurrence time</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__8">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_P"><h2 class="role-index-div-title">P<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__Ib"><span class="role-index-term">probability distribution function</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#SimModels__I__d">1</a></span></li></ul></div><div class="role-index-div" id="__I_TOC_R"><h2 class="role-index-div-title">R<a class="role-index-toc-ref" href="#__I_TOC" title="Back to the top of this page"></a></h2><ul class="role-index-entries"><li class="role-index-entry" id="__I7"><span class="role-index-term">random variable</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__7">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__c">2</a></span></li><li class="role-index-entry" id="__I6"><span class="role-index-term">recurrence</span>, <span class="role-index-anchor-refs"><a class="role-index-anchor-ref" href="#DesM__I__6">1</a>, <a class="role-index-anchor-ref" href="#SimModels__I__9">2</a></span></li></ul></div></section></div></section></body></html>